// Do not edit this file; automatically generated by build.py.
'use strict';

// This file tells what each block should generate (hence the name) in terms of Arduino language (C++)
var i = 0;

Blockly.Arduino = new Blockly.Generator("Arduino");
Blockly.Arduino.StaticTyping = new Blockly.StaticTyping;
Blockly.Arduino.addReservedWords("Blockly,setup,loop,if,else,for,switch,case,while,do,break,continue,return,goto,define,include,HIGH,LOW,INPUT,OUTPUT,INPUT_PULLUP,true,false,integer,constants,floating,point,void,boolean,char,unsigned,byte,int,word,long,float,double,string,String,array,static,volatile,const,sizeof,pinMode,digitalWrite,digitalRead,analogReference,analogRead,analogWrite,tone,noTone,shiftOut,shitIn,pulseIn,millis,micros,delay,delayMicroseconds,min,max,abs,constrain,map,pow,sqrt,sin,cos,tan,randomSeed,random,lowByte,highByte,bitRead,bitWrite,bitSet,bitClear,bit,attachInterrupt,detachInterrupt,interrupts,noInterrupts");
Blockly.Arduino.ORDER_ATOMIC = 0;
Blockly.Arduino.ORDER_UNARY_POSTFIX = 1;
Blockly.Arduino.ORDER_UNARY_PREFIX = 2;
Blockly.Arduino.ORDER_MULTIPLICATIVE = 3;
Blockly.Arduino.ORDER_ADDITIVE = 4;
Blockly.Arduino.ORDER_SHIFT = 5;
Blockly.Arduino.ORDER_RELATIONAL = 6;
Blockly.Arduino.ORDER_EQUALITY = 7;
Blockly.Arduino.ORDER_BITWISE_AND = 8;
Blockly.Arduino.ORDER_BITWISE_XOR = 9;
Blockly.Arduino.ORDER_BITWISE_OR = 10;
Blockly.Arduino.ORDER_LOGICAL_AND = 11;
Blockly.Arduino.ORDER_LOGICAL_OR = 12;
Blockly.Arduino.ORDER_CONDITIONAL = 13;
Blockly.Arduino.ORDER_ASSIGNMENT = 14;
Blockly.Arduino.ORDER_NONE = 99;
Blockly.Arduino.PinTypes = {
    INPUT: "INPUT",
    OUTPUT: "OUTPUT",
    PWM: "PWM",
    SERVO: "SERVO",
    STEPPER: "STEPPER",
    SERIAL: "SERIAL",
    I2C: "I2C/TWI",
    SPI: "SPI"
};
Blockly.Arduino.DEF_FUNC_NAME = Blockly.Arduino.FUNCTION_NAME_PLACEHOLDER_;
Blockly.Arduino.init = function (a) {
    Blockly.Arduino.includes_ = Object.create(null);
    Blockly.Arduino.definitions_ = Object.create(null);
    Blockly.Arduino.variables_ = Object.create(null);
    Blockly.Arduino.codeFunctions_ = Object.create(null);
    Blockly.Arduino.userFunctions_ = Object.create(null);
    Blockly.Arduino.functionNames_ = Object.create(null);
    Blockly.Arduino.setups_ = Object.create(null);
    Blockly.Arduino.setups_func_ = Object.create(null);
    Blockly.Arduino.loop_func_ = Object.create(null);
    Blockly.Arduino.pins_ = Object.create(null);
    Blockly.Arduino.variableDB_ ? Blockly.Arduino.variableDB_.reset() : Blockly.Arduino.variableDB_ =
        new Blockly.Names(Blockly.Arduino.RESERVED_WORDS_);
    // Blockly.Python.variableDB_.setVariableMap(a.getVariableMap());
    // for (var b = [], c = Blockly.Variables.allDeveloperVariables(a), d = 0; d < c.length; d++)
    // { 
    // b.push(Blockly.Python.variableDB_.getName(c[d], Blockly.Names.DEVELOPER_VARIABLE_TYPE) + " = None");
    // }
    // a = Blockly.Variables.allUsedVarModels(a);
    // for (d = 0; d < a.length; d++) b.push(Blockly.Python.variableDB_.getName(a[d].getId(), Blockly.Variables.NAME_TYPE) + " = None");
    // Blockly.Python.definitions_.variables = b.join(NEWLINE)

    // Below line added for the variable names to work
    Blockly.Arduino.variableDB_.setVariableMap(a.getVariableMap());

    var b = Blockly.Arduino.StaticTyping.collectVarsWithTypes(a);
    Blockly.Arduino.StaticTyping.setProcedureArgs(a, b);
    for (var c in b) {
        if (Blockly.Arduino.getArduinoType_(b[c]) != "Array") {
            Blockly.Arduino.addVariable(c, Blockly.Arduino.getArduinoType_(b[c]) + " " + Blockly.Arduino.variableDB_.getName(c, Blockly.Variables.NAME_TYPE) + ";")
        }
    }
};
Blockly.Arduino.finish = function (a) {
    var b = [],
        c = [],
        d = [],
        e = [],
        f;
    for (f in Blockly.Arduino.includes_) b.push(Blockly.Arduino.includes_[f]);
    b.length && b.push("\n");
    for (f in Blockly.Arduino.variables_) d.push(Blockly.Arduino.variables_[f]);
    d.length && d.push("\n");
    for (f in Blockly.Arduino.definitions_) c.push(Blockly.Arduino.definitions_[f]);
    c.length && c.push("\n");
    for (f in Blockly.Arduino.codeFunctions_) e.push(Blockly.Arduino.codeFunctions_[f]);
    for (f in Blockly.Arduino.userFunctions_) e.push(Blockly.Arduino.userFunctions_[f]);
    e.length && e.push("\n");
    var g = [""],
        h = "",
        j = [""],
        k = [""];
    void 0 !== Blockly.Arduino.setups_.userSetupCode && (h = "\n" + Blockly.Arduino.setups_.userSetupCode, delete Blockly.Arduino.setups_.userSetupCode);
    for (f in Blockly.Arduino.setups_) g.push(Blockly.Arduino.setups_[f]);
    h && g.push(h);
    for (f in Blockly.Arduino.setups_func_) j.push(Blockly.Arduino.setups_func_[f]);
    for (f in Blockly.Arduino.loop_func_) k.push(Blockly.Arduino.loop_func_[f]);
    delete Blockly.Arduino.includes_;
    delete Blockly.Arduino.definitions_;
    delete Blockly.Arduino.codeFunctions_;
    delete Blockly.Arduino.userFunctions_;
    delete Blockly.Arduino.functionNames_;
    delete Blockly.Arduino.setups_;
    delete Blockly.Arduino.setups_func_;
    delete Blockly.Arduino.loop_func_;
    delete Blockly.Arduino.pins_;
    Blockly.Arduino.variableDB_.reset();
    b = b.join("\n") + c.join("\n") + d.join("\n") + e.join("\n\n");
    // This for loop has been added to add indent on the setup block for the "automatic code generation"
    for (let i = 0; i < g.length; i++) {
        g[i] = "  " + g[i].replace(/[\n]/g, "\n  ");
    }
    // below, double spaces removed after "\n" in g.join and j.join (it caused 4 spaces instead of the 2 expected)
    g = "void setup() {" + g.join("\n") + j.join("\n") + "\n}\n\n";
    if (k[0] === "")
        k.splice(0, 1);
    if (k.length === 0)
        a = "void loop() {\n" + k.join("\n") + a + "}";
    else {
        a = "void loop() {\n" + k.join("\n") + a + "\n}";
    }
    return b + g + a
};
Blockly.Arduino.recurseArrayType = function (varName, varsWithTypes) {
    if (!varsWithTypes[varName].arrayType || varsWithTypes[varName].arrayType instanceof Blockly.Type) {
        var arrayDimension = '';
        if (varsWithTypes[varName].arrayType) {
            var subArray = varsWithTypes[varName].arrayType;
            arrayDimension = '[' + varsWithTypes[varName].arraySize + ']';
            while (subArray.arrayType) {
                arrayDimension += '[' + subArray.arraySize + ']';
                subArray = subArray.arrayType;
            }
            if (!(subArray instanceof Blockly.Type)) {
                varName = subArray[1];
                if (varsWithTypes[varName].arrayType) {
                    var varType = Blockly.Arduino.recurseArrayType(varName, varsWithTypes);
                    return varType.substr(0, varType.indexOf('[')) + arrayDimension + varType.substr(varType.indexOf('['));
                }
            }
        }
        return Blockly.Arduino.getArduinoType_(varsWithTypes[varName]) + arrayDimension;
    } else {
        var varTab = varsWithTypes[varName].arrayType[1];
        if (varTab == varName || !varsWithTypes[varTab]) {
            return 'undefined';
        } else {
            var varType = Blockly.Arduino.recurseArrayType(varTab, varsWithTypes);
            return Blockly.Arduino.insertParentArraySize(varType, varsWithTypes[varName].arraySize);
        }
    }
};
Blockly.Arduino.insertParentArraySize = function (varType, parentArraySize) {
    if (varType.indexOf('[') >= 0) {
        return varType.substr(0, varType.indexOf('[')) + '[' + parentArraySize + ']' + varType.substr(varType.indexOf('['));
    } else {
        return varType + '[' + parentArraySize + ']';
    }
};
Blockly.Arduino.addInclude = function (a, b) {
    void 0 === Blockly.Arduino.includes_[a] && (Blockly.Arduino.includes_[a] = b)
};
Blockly.Arduino.addDeclaration = function (a, b) {
    void 0 === Blockly.Arduino.definitions_[a] && (Blockly.Arduino.definitions_[a] = b)
};
Blockly.Arduino.addVariable = function (a, b, c) {
    var d = !1;
    if (c || void 0 === Blockly.Arduino.variables_[a]) Blockly.Arduino.variables_[a] = b, d = !0;
    return d
};
Blockly.Arduino.addSetup = function (a, b, c) {
    var d = !1;
    if (c || void 0 === Blockly.Arduino.setups_[a]) Blockly.Arduino.setups_[a] = b, d = !0;
    return d
};
Blockly.Arduino.addSetupFunc = function (a, b) {
    Blockly.Arduino.setups_func_[a] = b;
    return (true);
};
Blockly.Arduino.addLoopFunc = function (a, b) {
    Blockly.Arduino.loop_func_[a] = b;
    return (true);
}
Blockly.Arduino.addFunction = function (a, b) {
    if (void 0 === Blockly.Arduino.codeFunctions_[a]) {
        var c = Blockly.Arduino.variableDB_.getDistinctName(a, Blockly.Generator.NAME_TYPE);
        Blockly.Arduino.codeFunctions_[a] = b.replace(Blockly.Arduino.DEF_FUNC_NAME, c);
        Blockly.Arduino.functionNames_[a] = c
    }
    return Blockly.Arduino.functionNames_[a]
};
Blockly.Arduino.reservePin = function (a, b, c, d) {
    void 0 !== Blockly.Arduino.pins_[b] ? Blockly.Arduino.pins_[b] != c ? a.setWarningText(Blockly.Msg.ARD_PIN_WARN1.replace("%1", b).replace("%2", d).replace("%3", c).replace("%4", Blockly.Arduino.pins_[b]), d) : a.setWarningText(null, d) : (Blockly.Arduino.pins_[b] = c, a.setWarningText(null, d))
};
Blockly.Arduino.scrubNakedValue = function (a) {
    return a + ";\n"
};
Blockly.Arduino.quote_ = function (a) {
    a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n").replace(/\$/g, "\\$").replace(/'/g, "\\'");
    return '"' + a + '"'
};
Blockly.Arduino.scrub_ = function (a, b) {
    if (null === b) return "";
    var c = "";
    if (!a.outputConnection || !a.outputConnection.targetConnection) {
        var d = a.getCommentText();
        d && (c += this.prefixLines(d, "// ") + "\n");
        for (var e = 0; e < a.inputList.length; e++) a.inputList[e].type == Blockly.INPUT_VALUE && (d = a.inputList[e].connection.targetBlock()) && (d = this.allNestedComments(d)) && (c += this.prefixLines(d, "// "))
    }
    e = a.nextConnection && a.nextConnection.targetBlock();
    e = this.blockToCode(e);
    return c + b + e
};
Blockly.Arduino.getArduinoType_ = function (a) {
    switch (a.typeId) {
        case Blockly.Types.SHORT_NUMBER.typeId:
            return "char";
        case Blockly.Types.NUMBER.typeId:
            return "int";
        case Blockly.Types.LARGE_NUMBER.typeId:
            return "long";
        case Blockly.Types.DECIMAL.typeId:
            return "float";
        case Blockly.Types.TEXT.typeId:
            return "String";
        case Blockly.Types.CHARACTER.typeId:
            return "char";
        case Blockly.Types.BOOLEAN.typeId:
            return "boolean";
        case Blockly.Types.NULL.typeId:
            return "void";
        case Blockly.Types.UNDEF.typeId:
            return "undefined";
        case Blockly.Types.CHILD_BLOCK_MISSING.typeId:
            return "int";
        case Blockly.Types.ARRAY.typeId:
            return "Array";
        default:
            return "Invalid Blockly Type"
    }
};
Blockly.Arduino.noGeneratorCodeInline = function () {
    return ["", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.noGeneratorCodeLine = function () {
    return ""
};
Blockly.Arduino.Boards = {};
Blockly.Arduino.Boards.generateDigitalIo = function (a, b) {
    for (var c = [], d = a; d < b + 1; d++) c.push([d.toString(), d.toString()]);
    return c
};
Blockly.Arduino.Boards.generateAnalogIo = function (a, b) {
    for (var c = [], d = a; d < b + 1; d++) c.push(["A" + d.toString(), "A" + d.toString()]);
    return c
};
Blockly.Arduino.Boards.duplicateBoardProfile = function (a, b, c, d) {
    return {
        name: b,
        description: c || a.description,
        compilerFlag: d || a.compilerFlag,
        analogPins: a.analogPins,
        digitalPins: a.digitalPins,
        pwmPins: a.pwmPins,
        serial: a.serial,
        serialPins: a.serialPins,
        serialSpeed: a.serialSpeed,
        spi: a.spi,
        spiPins: a.spiPins,
        spiClockDivide: a.spiClockDivide,
        i2c: a.i2c,
        i2cPins: a.i2cPins,
        i2cSpeed: a.i2cSpeed,
        builtinLed: a.builtinLed,
        interrupt: a.interrupt
    }
};
Blockly.Arduino.Boards.profiles = {};
Blockly.Arduino.Boards.profiles.uno = {
    name: "Arduino Uno",
    description: "Arduino Uno standard compatible board",
    compilerFlag: "arduino:avr:uno",
    analogPins: Blockly.Arduino.Boards.generateAnalogIo(0, 5),
    digitalPins: Blockly.Arduino.Boards.generateDigitalIo(0, 13).concat(Blockly.Arduino.Boards.generateAnalogIo(0, 5)),
    pwmPins: [
        ["3", "3"],
        ["5", "5"],
        ["6", "6"],
        ["9", "9"],
        ["10", "10"],
        ["11", "11"]
    ],
    serial: [
        ["serial", "Serial"]
    ],
    serialPins: {
        Serial: [
            ["RX", "0"],
            ["TX", "1"]
        ]
    },
    serialSpeed: [
        ["300", "300"],
        ["600", "600"],
        ["1200", "1200"],
        ["2400", "2400"],
        ["4800", "4800"],
        ["9600", "9600"],
        ["14400", "14400"],
        ["19200", "19200"],
        ["28800", "28800"],
        ["31250", "31250"],
        ["38400", "38400"],
        ["57600", "57600"],
        ["115200", "115200"]
    ],
    spi: [
        ["SPI", "SPI"]
    ],
    spiPins: {
        SPI: [
            ["MOSI", "11"],
            ["MISO", "12"],
            ["SCK", "13"]
        ]
    },
    spiClockDivide: [
        ["2 (8MHz)", "SPI_CLOCK_DIV2"],
        ["4 (4MHz)", "SPI_CLOCK_DIV4"],
        ["8 (2MHz)", "SPI_CLOCK_DIV8"],
        ["16 (1MHz)", "SPI_CLOCK_DIV16"],
        ["32 (500KHz)", "SPI_CLOCK_DIV32"],
        ["64 (250KHz)", "SPI_CLOCK_DIV64"],
        ["128 (125KHz)", "SPI_CLOCK_DIV128"]
    ],
    i2c: [
        ["I2C", "Wire"]
    ],
    i2cPins: {
        Wire: [
            ["SDA", "A4"],
            ["SCL", "A5"]
        ]
    },
    i2cSpeed: [
        ["100kHz", "100000L"],
        ["400kHz", "400000L"]
    ],
    builtinLed: [
        ["BUILTIN_1", "13"]
    ],
    interrupt: [
        ["interrupt0", "2"],
        ["interrupt1", "3"]
    ]
};
Blockly.Arduino.Boards.profiles.nano_328 = {
    name: "Arduino Nano 328",
    description: "Arduino Nano with ATmega328 board",
    compilerFlag: "arduino:avr:nano:cpu=atmega328",
    analogPins: Blockly.Arduino.Boards.generateAnalogIo(0, 7),
    digitalPins: Blockly.Arduino.Boards.generateDigitalIo(0, 13).concat(Blockly.Arduino.Boards.generateAnalogIo(0, 7)),
    pwmPins: Blockly.Arduino.Boards.profiles.uno.pwmPins,
    serial: Blockly.Arduino.Boards.profiles.uno.serial,
    serialPins: Blockly.Arduino.Boards.profiles.uno.serialPins,
    serialSpeed: Blockly.Arduino.Boards.profiles.uno.serialSpeed,
    spi: Blockly.Arduino.Boards.profiles.uno.spi,
    spiPins: Blockly.Arduino.Boards.profiles.uno.spiPins,
    spiClockDivide: Blockly.Arduino.Boards.profiles.uno.spiClockDivide,
    i2c: Blockly.Arduino.Boards.profiles.uno.i2c,
    i2cPins: Blockly.Arduino.Boards.profiles.uno.i2cPins,
    i2cSpeed: Blockly.Arduino.Boards.profiles.uno.i2cSpeed,
    builtinLed: Blockly.Arduino.Boards.profiles.uno.builtinLed,
    interrupt: Blockly.Arduino.Boards.profiles.uno.interrupt
};
Blockly.Arduino.Boards.profiles.nano_168 = Blockly.Arduino.Boards.duplicateBoardProfile(Blockly.Arduino.Boards.profiles.nano_328, "Arduino Nano 168", "Arduino Nano with ATmega168 compatible board", "arduino:avr:nano:cpu=atmega168");
Blockly.Arduino.Boards.profiles.duemilanove_168p = {
    name: "Arduino Nano 168p",
    description: "Arduino Duemilanove with ATmega168p compatible board",
    compilerFlag: "arduino:avr:diecimila:cpu=atmega168",
    analogPins: Blockly.Arduino.Boards.profiles.uno.analogPins,
    digitalPins: Blockly.Arduino.Boards.profiles.uno.digitalPins,
    pwmPins: Blockly.Arduino.Boards.profiles.uno.pwmPins,
    serial: Blockly.Arduino.Boards.profiles.uno.serial,
    serialPins: Blockly.Arduino.Boards.profiles.uno.serialPins,
    serialSpeed: Blockly.Arduino.Boards.profiles.uno.serialSpeed,
    spi: Blockly.Arduino.Boards.profiles.uno.spi,
    spiPins: Blockly.Arduino.Boards.profiles.uno.spiPins,
    spiClockDivide: Blockly.Arduino.Boards.profiles.uno.spiClockDivide,
    i2c: Blockly.Arduino.Boards.profiles.uno.i2c,
    i2cPins: Blockly.Arduino.Boards.profiles.uno.i2cPins,
    i2cSpeed: Blockly.Arduino.Boards.profiles.uno.i2cSpeed,
    builtinLed: Blockly.Arduino.Boards.profiles.uno.builtinLed,
    interrupt: Blockly.Arduino.Boards.profiles.uno.interrupt
};
Blockly.Arduino.Boards.profiles.duemilanove_328p = Blockly.Arduino.Boards.duplicateBoardProfile(Blockly.Arduino.Boards.profiles.duemilanove_168p, "Arduino Duemilanove 328p", "Arduino Duemilanove with ATmega328p compatible board", "arduino:avr:diecimila");
Blockly.Arduino.Boards.profiles.mega = {
    name: "Arduino Mega",
    description: "Arduino Mega-compatible board",
    compilerFlag: "arduino:avr:mega",
    analogPins: Blockly.Arduino.Boards.generateAnalogIo(0, 15),
    digitalPins: Blockly.Arduino.Boards.generateDigitalIo(0, 53),
    pwmPins: Blockly.Arduino.Boards.generateDigitalIo(2, 13).concat(Blockly.Arduino.Boards.generateDigitalIo(44, 46)),
    serial: [
        ["serial", "Serial"],
        ["serial_1", "Serial1"],
        ["serial_2", "Serial2"],
        ["serial_3", "Serial3"]
    ],
    serialPins: {
        Serial: [
            ["TX", "0"],
            ["RX", "1"]
        ],
        Serial1: [
            ["TX", "18"],
            ["TX", "19"]
        ],
        Serial2: [
            ["TX", "16"],
            ["TX", "17"]
        ],
        Serial3: [
            ["TX", "14"],
            ["TX", "15"]
        ]
    },
    serialSpeed: Blockly.Arduino.Boards.profiles.uno.serialSpeed,
    spi: [
        ["SPI", "SPI"]
    ],
    spiPins: {
        SPI: [
            ["MOSI", "51"],
            ["MISO", "50"],
            ["SCK", "52"]
        ]
    },
    spiClockDivide: Blockly.Arduino.Boards.profiles.uno.spiClockDivide,
    i2c: [
        ["I2C", "Wire"]
    ],
    i2cPins: {
        Wire: [
            ["SDA", "20"],
            ["SCL", "21"]
        ]
    },
    i2cSpeed: [
        ["100kHz", "100000L"],
        ["400kHz", "400000L"]
    ],
    builtinLed: Blockly.Arduino.Boards.profiles.uno.builtinLed,
    interrupt: [
        ["interrupt0",
            "2"
        ],
        ["interrupt1", "3"],
        ["interrupt2", "21"],
        ["interrupt3", "20"],
        ["interrupt4", "19"],
        ["interrupt5", "18"]
    ]
};
Blockly.Arduino.Boards.profiles.leonardo = {
    name: "Arduino Leonardo",
    description: "Arduino Leonardo-compatible board",
    compilerFlag: "arduino:avr:leonardo",
    analogPins: Blockly.Arduino.Boards.generateAnalogIo(0, 5).concat([
        ["A6", "4"],
        ["A7", "6"],
        ["A8", "8"],
        ["A9", "9"],
        ["A10", "10"],
        ["A11", "12"]
    ]),
    digitalPins: Blockly.Arduino.Boards.generateDigitalIo(0, 13).concat(Blockly.Arduino.Boards.generateAnalogIo(0, 5)),
    pwmPins: Blockly.Arduino.Boards.profiles.uno.pwmPins.concat([
        ["13", "13"]
    ]),
    serial: Blockly.Arduino.Boards.profiles.uno.serial,
    serialPins: Blockly.Arduino.Boards.profiles.uno.serialPins,
    serialSpeed: Blockly.Arduino.Boards.profiles.uno.serialSpeed,
    spi: [
        ["SPI", "SPI"]
    ],
    spiPins: {
        SPI: [
            ["MOSI", "ICSP-4"],
            ["MISO", "ICSP-1"],
            ["SCK", "ICSP-3"]
        ]
    },
    spiClockDivide: Blockly.Arduino.Boards.profiles.uno.spiClockDivide,
    i2c: [
        ["I2C", "Wire"]
    ],
    i2cPins: {
        Wire: [
            ["SDA", "2"],
            ["SCL", "3"]
        ]
    },
    i2cSpeed: Blockly.Arduino.Boards.profiles.uno.i2cSpeed,
    builtinLed: Blockly.Arduino.Boards.profiles.uno.builtinLed,
    interrupt: [
        ["interrupt0", "3"],
        ["interrupt1", "2"],
        ["interrupt2",
            "0"
        ],
        ["interrupt3", "1"],
        ["interrupt4", "17"]
    ]
};
Blockly.Arduino.Boards.profiles.yun = Blockly.Arduino.Boards.duplicateBoardProfile(Blockly.Arduino.Boards.profiles.leonardo, "Arduino Yun", "Arduino Yun compatible board");
Blockly.Arduino.Boards.profiles.atmel_atmega328p_xplained_mini = {
    name: "Atmel atmega328p Xplained mini",
    description: "Atmel Xplained mini board with atmega328p (Uno compatible)",
    compilerFlag: "atmel:avr:atmega328p_xplained_mini",
    analogPins: Blockly.Arduino.Boards.profiles.uno.analogPins,
    digitalPins: Blockly.Arduino.Boards.profiles.uno.digitalPins.concat([
        ["20", "20"]
    ]),
    pwmPins: Blockly.Arduino.Boards.profiles.uno.pwmPins,
    serial: Blockly.Arduino.Boards.profiles.uno.serial,
    serialPins: Blockly.Arduino.Boards.profiles.uno.serialPins,
    serialSpeed: Blockly.Arduino.Boards.profiles.uno.serialSpeed,
    spi: Blockly.Arduino.Boards.profiles.uno.spi,
    spiPins: Blockly.Arduino.Boards.profiles.uno.spiPins,
    spiClockDivide: Blockly.Arduino.Boards.profiles.uno.spiClockDivide,
    i2c: Blockly.Arduino.Boards.profiles.uno.i2c,
    i2cPins: Blockly.Arduino.Boards.profiles.uno.i2cPins,
    i2cSpeed: Blockly.Arduino.Boards.profiles.uno.i2cSpeed,
    builtinLed: [
        ["BUILTIN_LED", "13"]
    ],
    interrupt: Blockly.Arduino.Boards.profiles.uno.interrupt,
    builtinButton: [
        ["BUILTIN_BUTTON", "20"]
    ]
};
Blockly.Arduino.Boards.profiles.atmel_atmega328pb_xplained_mini = Blockly.Arduino.Boards.duplicateBoardProfile(Blockly.Arduino.Boards.profiles.atmel_atmega328p_xplained_mini, "Atmel atmega328pb Xplained mini", "Atmel Xplained mini board with atmega328pb (Arduino Uno compatible)", "atmel:avr:atmega328pb_xplained_mini");
Blockly.Arduino.Boards.profiles.atmel_atmega168pb_xplained_mini = Blockly.Arduino.Boards.duplicateBoardProfile(Blockly.Arduino.Boards.profiles.atmel_atmega328p_xplained_mini, "Atmel atmega168pb Xplained mini", "Atmel Xplained mini board with atmega168pb (Arduino Uno compatible)", "atmel:avr:atmega168pb_xplained_mini");
Blockly.Arduino.Boards.profiles.esp8266_huzzah = {
    name: "Adafruit Feather HUZZAH",
    description: "Adafruit HUZZAH ESP8266 compatible board",
    compilerFlag: "esp8266:esp8266:generic",
    analogPins: [
        ["A0", "A0"]
    ],
    digitalPins: [
        ["0", "0"],
        ["2", "2"],
        ["4", "4"],
        ["5", "5"],
        ["12", "12"],
        ["13", "13"],
        ["14", "14"],
        ["15", "15"],
        ["16", "16"]
    ],
    pwmPins: [
        ["2", "2"]
    ],
    serial: [
        ["serial", "Serial"]
    ],
    serialPins: {
        Serial: [
            ["RX", "RX"],
            ["TX", "TX"]
        ]
    },
    serialSpeed: Blockly.Arduino.Boards.profiles.uno.serial,
    spi: [
        ["SPI", "SPI"]
    ],
    spiPins: {
        SPI: [
            ["MOSI",
                "13"
            ],
            ["MISO", "12"],
            ["SCK", "14"]
        ]
    },
    spiClockDivide: Blockly.Arduino.Boards.profiles.uno.spiClockDivide,
    i2c: [
        ["I2C", "Wire"]
    ],
    i2cPins: {
        Wire: [
            ["SDA", "4"],
            ["SCL", "5"]
        ]
    },
    i2cSpeed: Blockly.Arduino.Boards.profiles.uno.i2cSpeed,
    builtinLed: [
        ["BUILTIN_1", "0"]
    ],
    interrupt: [
        ["interrupt0", "2"],
        ["interrupt1", "3"]
    ]
};
Blockly.Arduino.Boards.profiles.esp8266_wemos_d1 = {
    name: "Wemos D1",
    description: "Wemos D1 R2 compatible board",
    compilerFlag: "esp8266:esp8266:generic",
    analogPins: [
        ["A0", "A0"]
    ],
    digitalPins: [
        ["D0", "D0"],
        ["D1", "D1"],
        ["D2", "D2"],
        ["D3", "D3"],
        ["D4", "D4"],
        ["D5", "D5"],
        ["D6", "D7"],
        ["D8", "D8"]
    ],
    pwmPins: [
        ["D1", "D1"],
        ["D2", "D2"],
        ["D3", "D3"],
        ["D4", "D4"],
        ["D5", "D5"],
        ["D6", "D7"],
        ["D8", "D8"]
    ],
    serial: [
        ["serial", "Serial"]
    ],
    serialPins: {
        Serial: [
            ["RX", "RX"],
            ["TX", "TX"]
        ]
    },
    serialSpeed: Blockly.Arduino.Boards.profiles.uno.serialSpeed,
    spi: [
        ["SPI", "SPI"]
    ],
    spiPins: {
        SPI: [
            ["MOSI", "D7"],
            ["MISO", "D6"],
            ["SCK", "D5"]
        ]
    },
    spiClockDivide: Blockly.Arduino.Boards.profiles.uno.spiClockDivide,
    i2c: [
        ["I2C", "Wire"]
    ],
    i2cPins: {
        Wire: [
            ["SDA", "D2"],
            ["SCL", "D1"]
        ]
    },
    i2cSpeed: Blockly.Arduino.Boards.profiles.uno.i2cSpeed,
    builtinLed: [
        ["BUILTIN_1", "D4"]
    ],
    interrupt: [
        ["D0", "D0"],
        ["D1", "D1"],
        ["D2", "D2"],
        ["D3", "D3"],
        ["D4", "D4"],
        ["D5", "D5"],
        ["D6", "D7"],
        ["D8", "D8"]
    ]
};
Blockly.Arduino.Boards.selected = Blockly.Arduino.Boards.profiles.uno;
Blockly.Arduino.Boards.changeBoard = function (a, b) {
    if (void 0 === Blockly.Arduino.Boards.profiles[b]) console.log("Tried to set non-existing Arduino board: " + b);
    else {
        Blockly.Arduino.Boards.selected = Blockly.Arduino.Boards.profiles[b];
        for (var c = a.getAllBlocks(), d = 0; d < c.length; d++) {
            var e = c[d].updateFields;
            e && e.call(c[d])
        }
    }
};
Blockly.Arduino.Boards.refreshBlockFieldDropdown = function (a, b, c) {
    var d = a.getField(b);
    b = d.getValue();
    c = Blockly.Arduino.Boards.selected[c];
    d.menuGenerator_ = c;
    for (var d = !1, e = 0; e < c.length; e++) b == c[e][1] && (d = !0);
    d ? a.setWarningText(null, "bPin") : a.setWarningText("The old pin value " + b + " is no longer available.", "bPin")
};

/////////////////////////////////////////////// LOGIC CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.controls_if = function (a) {
    for (var b = 0, c = Blockly.Arduino.valueToCode(a, "IF" + b, Blockly.Arduino.ORDER_NONE) || "false", d = Blockly.Arduino.statementToCode(a, "DO" + b), e = "if (" + c + ") {\n" + d + "}", b = 1; b <= a.elseifCount_; b++) c = Blockly.Arduino.valueToCode(a, "IF" + b, Blockly.Arduino.ORDER_NONE) || "false", d = Blockly.Arduino.statementToCode(a, "DO" + b), e += " else if (" + c + ") {\n" + d + "}";
    a.elseCount_ && (d = Blockly.Arduino.statementToCode(a, "ELSE"), e += " else {\n" + d + "}");
    return e + "\n"
};
Blockly.Arduino.logic_compare = function (a) {
    var b = {
            EQ: "==",
            NEQ: "!=",
            LT: "<",
            LTE: "<=",
            GT: ">",
            GTE: ">="
        } [a.getFieldValue("OP")],
        c = "==" == b || "!=" == b ? Blockly.Arduino.ORDER_EQUALITY : Blockly.Arduino.ORDER_RELATIONAL,
        d = Blockly.Arduino.valueToCode(a, "A", c) || "0";
    a = Blockly.Arduino.valueToCode(a, "B", c) || "0";
    return [d + " " + b + " " + a, c]
};
Blockly.Arduino.logic_operation = function (a) {
    var b = "AND" == a.getFieldValue("OP") ? "&&" : "||",
        c = "&&" == b ? Blockly.Arduino.ORDER_LOGICAL_AND : Blockly.Arduino.ORDER_LOGICAL_OR,
        d = Blockly.Arduino.valueToCode(a, "A", c) || "false";
    a = Blockly.Arduino.valueToCode(a, "B", c) || "false";
    if (d || a) {
        var e = "&&" == b ? "true" : "false";
        d || (d = e);
        a || (a = e)
    } else a = d = "false";
    return [d + " " + b + " " + a, c]
};
Blockly.Arduino.logic_negate = function (a) {
    var b = Blockly.Arduino.ORDER_UNARY_PREFIX;
    return ["!" + (Blockly.Arduino.valueToCode(a, "BOOL", b) || "false"), b]
};
Blockly.Arduino.logic_boolean = function (a) {
    return ["TRUE" == a.getFieldValue("BOOL") ? "true" : "false", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.logic_null = function () {
    return ["NULL", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.logic_ternary = function (a) {
    let test = Blockly.Arduino.valueToCode(this, "IF", Blockly.Arduino.ORDER_ATOMIC) || "0";
    let b = Blockly.Arduino.valueToCode(this, "THEN", Blockly.Arduino.ORDER_ATOMIC) || "0 ";
    let c = Blockly.Arduino.valueToCode(this, "ELSE", Blockly.Arduino.ORDER_ATOMIC) || "0";
    let d = Blockly.Types.CHILD_BLOCK_MISSING;
    var trueReturn = a.inputList[1].connection.targetBlock();
    var falseReturn = a.inputList[2].connection.targetBlock();
    if (trueReturn && falseReturn) {
        if (trueReturn.outputConnection && falseReturn.outputConnection) {
            // if child is a "normal" block
            if(trueReturn.outputConnection.check_) {
                d = trueReturn.outputConnection.check_[0];
            // if child is a 'variable'
            }else if (trueReturn.type == 'variables_get') {
                for (let variable of Object.entries(Blockly.Arduino.StaticTyping.varTypeDict)) {
                    if (trueReturn.inputList[0].fieldRow[0].text_ == variable[0]) {
                        d = variable[1].typeId;
                    }
                };
            }
        }
        d = Blockly.Types.getValidTypeWithId(d);
    }
    a.getReturnType && (d = a.getReturnType());
    d = Blockly.Arduino.getArduinoType_(d);
    let func = d + " testStateOf(boolean test) {" + NEWLINE 
             + "  if (test) return " + b + ";" + NEWLINE 
             + "  else return " + c + ";" + NEWLINE 
             + "}";
    Blockly.Arduino.addFunction("test_true_false", func);
    return ["testStateOf(" + test + ")", Blockly.Arduino.ORDER_ATOMIC]
};

/////////////////////////////////////////////// LOOPS CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.controls_repeat_ext = function (a) {
    var b = Blockly.Arduino.valueToCode(a, "TIMES", Blockly.Arduino.ORDER_ADDITIVE) || "0",
        c = Blockly.Arduino.statementToCode(a, "DO"),
        c = Blockly.Arduino.addLoopTrap(c, a.id);
    a = "";
    var d = Blockly.Arduino.variableDB_.getDistinctName("count", Blockly.Variables.NAME_TYPE),
        e = b;
    b.match(/^\w+$/) || Blockly.isNumber(b) || (e = Blockly.Arduino.variableDB_.getDistinctName("repeat_end", Blockly.Variables.NAME_TYPE), a += "int " + e + " = " + b + ";\n");
    return a + ("for (int " + d + " = 0; " + d + " < " +
        e + "; " + d + "++) {\n" + c + "}\n")
};
Blockly.Arduino.controls_whileUntil = function (a) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = Blockly.Arduino.valueToCode(a, "BOOL", b ? Blockly.Arduino.ORDER_LOGICAL_OR : Blockly.Arduino.ORDER_NONE) || "false",
        d = Blockly.Arduino.statementToCode(a, "DO"),
        d = Blockly.Arduino.addLoopTrap(d, a.id);
    b && (c.match(/^\w+$/) || (c = "(" + c + ")"), c = "!" + c);
    return "while (" + c + ") {\n" + d + "}\n"
};
Blockly.Arduino.controls_for = function (a) {
    var b = Blockly.Arduino.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE),
        c = Blockly.Arduino.valueToCode(a, "FROM", Blockly.Arduino.ORDER_ASSIGNMENT) || "0",
        d = Blockly.Arduino.valueToCode(a, "TO", Blockly.Arduino.ORDER_ASSIGNMENT) || "0",
        e = Blockly.Arduino.valueToCode(a, "BY", Blockly.Arduino.ORDER_ASSIGNMENT) || "1",
        f = Blockly.Arduino.statementToCode(a, "DO"),
        f = Blockly.Arduino.addLoopTrap(f, a.id);
    if (Blockly.isNumber(c) && Blockly.isNumber(d) && Blockly.isNumber(e)) {
        var g =
            parseFloat(c) <= parseFloat(d);
        a = "for (" + b + " = " + c + "; " + b + (g ? " <= " : " >= ") + d + "; " + b;
        b = Math.abs(parseFloat(e));
        a = (1 == b ? a + (g ? "++" : "--") : a + ((g ? " += " : " -= ") + b)) + (") {\n" + f + "}\n")
    } else a = "", g = c, c.match(/^\w+$/) || Blockly.isNumber(c) || (g = Blockly.Arduino.variableDB_.getDistinctName(b + "_start", Blockly.Variables.NAME_TYPE), a += "int " + g + " = " + c + ";\n"), c = d, d.match(/^\w+$/) || Blockly.isNumber(d) || (c = Blockly.Arduino.variableDB_.getDistinctName(b + "_end", Blockly.Variables.NAME_TYPE), a += "int " + c + " = " + d + ";\n"), d = Blockly.Arduino.variableDB_.getDistinctName(b +
        "_inc", Blockly.Variables.NAME_TYPE), a += "int " + d + " = ", a = Blockly.isNumber(e) ? a + (Math.abs(e) + ";\n") : a + ("abs(" + e + ");\n"), a = a + ("if (" + g + " > " + c + ") {\n") + (Blockly.Arduino.INDENT + d + " = -" + d + ";\n"), a += "}\n", a += "for (" + b + " = " + g + ";\n     " + d + " >= 0 ? " + b + " <= " + c + " : " + b + " >= " + c + ";\n     " + b + " += " + d + ") {\n" + f + "}\n";
    return a
};
Blockly.Arduino.controls_flow_statements = function (a) {
    switch (a.getFieldValue("FLOW")) {
        case "BREAK":
            return "break;" + NEWLINE;
        case "CONTINUE":
            return "continue;" + NEWLINE;
    }
    throw "Unknown flow statement.";
};

/////////////////////////////////////////////// MATHS CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.math_number = function (a) {
    a = parseFloat(a.getFieldValue("NUM"));
    Infinity == a ? a = "INFINITY" : -Infinity == a && (a = "-INFINITY");
    return [a, Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.math_arithmetic = function (a) {
    var b = {
            ADD: [" + ", Blockly.Arduino.ORDER_ADDITIVE],
            MINUS: [" - ", Blockly.Arduino.ORDER_ADDITIVE],
            MULTIPLY: [" * ", Blockly.Arduino.ORDER_MULTIPLICATIVE],
            DIVIDE: [" / ", Blockly.Arduino.ORDER_MULTIPLICATIVE],
            POWER: [null, Blockly.Arduino.ORDER_NONE]
        } [a.getFieldValue("OP")],
        c = b[0],
        b = b[1],
        d = Blockly.Arduino.valueToCode(a, "A", b) || "0";
    a = Blockly.Arduino.valueToCode(a, "B", b) || "0";
    return c ? [d + c + a, b] : ["Math.pow(" + d + ", " + a + ")", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.math_single = function (a) {
    var b = a.getFieldValue("OP"),
        c;
    if ("NEG" == b) return a = Blockly.Arduino.valueToCode(a, "NUM", Blockly.Arduino.ORDER_UNARY_PREFIX) || "0", "-" == a[0] && (a = " " + a), ["-" + a, Blockly.Arduino.ORDER_UNARY_PREFIX];
    a = "ABS" == b || "ROUND" == b.substring(0, 5) ? Blockly.Arduino.valueToCode(a, "NUM", Blockly.Arduino.ORDER_UNARY_POSTFIX) || "0" : "SIN" == b || "COS" == b || "TAN" == b ? Blockly.Arduino.valueToCode(a, "NUM", Blockly.Arduino.ORDER_MULTIPLICATIVE) || "0" : Blockly.Arduino.valueToCode(a, "NUM", Blockly.Arduino.ORDER_NONE) ||
        "0";
    switch (b) {
        case "ABS":
            c = "abs(" + a + ")";
            break;
        case "ROOT":
            c = "sqrt(" + a + ")";
            break;
        case "LN":
            c = "log(" + a + ")";
            break;
        case "EXP":
            c = "exp(" + a + ")";
            break;
        case "POW10":
            c = "pow(10," + a + ")";
            break;
        case "ROUND":
            c = "round(" + a + ")";
            break;
        case "ROUNDUP":
            c = "ceil(" + a + ")";
            break;
        case "ROUNDDOWN":
            c = "floor(" + a + ")";
            break;
        case "SIN":
            c = "sin(" + a + " / 180 * M_PI)";
            break;
        case "COS":
            c = "cos(" + a + " / 180 * M_PI)";
            break;
        case "TAN":
            c = "tan(" + a + " / 180 * M_PI)"
    }
    if (c) return [c, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    switch (b) {
        case "LOG10":
            c = "log(" + a + ") / log(10)";
            break;
        case "ASIN":
            c = "asin(" + a + ") / M_PI * 180";
            break;
        case "ACOS":
            c = "acos(" + a + ") / M_PI * 180";
            break;
        case "ATAN":
            c = "atan(" + a + ") / M_PI * 180";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    return [c, Blockly.Arduino.ORDER_MULTIPLICATIVE]
};
Blockly.Arduino.math_constant = function (a) {
    return {
        PI: ["M_PI", Blockly.Arduino.ORDER_UNARY_POSTFIX],
        E: ["M_E", Blockly.Arduino.ORDER_UNARY_POSTFIX],
        GOLDEN_RATIO: ["(1 + sqrt(5)) / 2", Blockly.Arduino.ORDER_MULTIPLICATIVE],
        SQRT2: ["M_SQRT2", Blockly.Arduino.ORDER_UNARY_POSTFIX],
        SQRT1_2: ["M_SQRT1_2", Blockly.Arduino.ORDER_UNARY_POSTFIX],
        INFINITY: ["INFINITY", Blockly.Arduino.ORDER_ATOMIC]
    } [a.getFieldValue("CONSTANT")]
};
Blockly.Arduino.math_number_property = function (a) {
    var b = Blockly.Arduino.valueToCode(a, "NUMBER_TO_CHECK", Blockly.Arduino.ORDER_MULTIPLICATIVE) || "0",
        c = a.getFieldValue("PROPERTY"),
        d;
    if ("PRIME" == c) return a = Blockly.Arduino.addFunction("mathIsPrime", ["boolean " + Blockly.Arduino.DEF_FUNC_NAME + "(int n) {", "  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n  if (n == 2 || n == 3) {\n    return true;\n  }\n  // False if n is NaN, negative, is 1.\n  // And false if n is divisible by 2 or 3.\n  if (isnan(n) || (n <= 1) || (n == 1) || (n % 2 == 0) || (n % 3 == 0)) {\n    return false;\n  }\n  // Check all the numbers of form 6k +/- 1, up to sqrt(n).\n  for (int x = 6; x <= sqrt(n) + 1; x += 6) {\n    if (n % (x - 1) == 0 || n % (x + 1) == 0) {\n      return false;\n    }\n  }\n  return true;\n}"].join("\n")),
        Blockly.Arduino.addInclude("math", INCLUDE_MATH), [a + "(" + b + ")", Blockly.Arduino.ORDER_UNARY_POSTFIX];
    switch (c) {
        case "EVEN":
            d = b + " % 2 == 0";
            break;
        case "ODD":
            d = b + " % 2 == 1";
            break;
        case "WHOLE":
            Blockly.Arduino.addInclude("math", INCLUDE_MATH);
            d = "(floor(" + b + ") == " + b + ")";
            break;
        case "POSITIVE":
            d = b + " > 0";
            break;
        case "NEGATIVE":
            d = b + " < 0";
            break;
        case "DIVISIBLE_BY":
            a = Blockly.Arduino.valueToCode(a, "DIVISOR", Blockly.Arduino.ORDER_MULTIPLICATIVE) || "0", d = b + " % " + a + " == 0"
    }
    return [d, Blockly.Arduino.ORDER_EQUALITY]
};
Blockly.Arduino.math_map = function () {
    var value1 = Blockly.Arduino.valueToCode(this, "VALUE1", Blockly.Arduino.ORDER_ATOMIC);
    var value2 = Blockly.Arduino.valueToCode(this, "VALUE2", Blockly.Arduino.ORDER_ATOMIC);
    var value3 = Blockly.Arduino.valueToCode(this, "VALUE3", Blockly.Arduino.ORDER_ATOMIC);
    var value4 = Blockly.Arduino.valueToCode(this, "VALUE4", Blockly.Arduino.ORDER_ATOMIC);
    var value5 = Blockly.Arduino.valueToCode(this, "VALUE5", Blockly.Arduino.ORDER_ATOMIC);
    return ["map(" + value1 + "," + value2 + "," + value3 + "," + value4 + "," + value5 + ")", Blockly.Arduino.ORDER_ATOMIC];
};
Blockly.Arduino.variables_increment = function (a) {
    var b = Blockly.Arduino.valueToCode(a, "DELTA", Blockly.Arduino.ORDER_ADDITIVE) || "0";
    return Blockly.Arduino.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE) + " += " + b + ";" + NEWLINE;
};
Blockly.Arduino.math_round = Blockly.Arduino.math_single;
Blockly.Arduino.math_trig = Blockly.Arduino.math_single;
//Blockly.Arduino.math_on_list = Blockly.Arduino.noGeneratorCodeInline;
Blockly.Arduino.math_modulo = function (a) {
    var b = Blockly.Arduino.valueToCode(a, "DIVIDEND", Blockly.Arduino.ORDER_MULTIPLICATIVE) || "0";
    a = Blockly.Arduino.valueToCode(a, "DIVISOR", Blockly.Arduino.ORDER_MULTIPLICATIVE) || "0";
    return [b + " % " + a, Blockly.Arduino.ORDER_MULTIPLICATIVE]
};
Blockly.Arduino.math_constrain = function (a) {
    var b = Blockly.Arduino.valueToCode(a, "VALUE", Blockly.Arduino.ORDER_NONE) || "0",
        c = Blockly.Arduino.valueToCode(a, "LOW", Blockly.Arduino.ORDER_NONE) || "0";
    a = Blockly.Arduino.valueToCode(a, "HIGH", Blockly.Arduino.ORDER_NONE) || "0";
    return ["(" + b + " < " + c + " ? " + c + " : ( " + b + " > " + a + " ? " + a + " : " + b + "))", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.math_random_int = function (a) {
    var b = Blockly.Arduino.valueToCode(a, "FROM", Blockly.Arduino.ORDER_NONE) || "0";
    a = Blockly.Arduino.valueToCode(a, "TO", Blockly.Arduino.ORDER_NONE) || "0";
    var c = Blockly.Arduino.variableDB_.getDistinctName("math_random_int", Blockly.Generator.NAME_TYPE);
    Blockly.Arduino.math_random_int.random_function = c;
    return [Blockly.Arduino.addFunction("mathRandomInt", ["int " + Blockly.Arduino.DEF_FUNC_NAME + "(int min, int max) {", "  if (min > max) {\n    // Swap min and max to ensure min is smaller.\n    int temp = min;\n    min = max;\n    max = temp;\n  }\n  return min + (rand() % (max - min + 1));\n}"].join("\n")) +
        "(" + b + ", " + a + ")", Blockly.Arduino.ORDER_UNARY_POSTFIX
    ]
};
Blockly.Arduino.math_random_float = function (a) {
    return ["(rand() / RAND_MAX)", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};

/////////////////////////////////////////////// TEXT CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.text = function (a) {
    return [Blockly.Arduino.quote_(a.getFieldValue("TEXT")), Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.text_join = function (a) {
    var b;
    if (0 == a.itemCount_) return ['""', Blockly.Arduino.ORDER_ATOMIC];
    if (1 == a.itemCount_) return ["String(" + (Blockly.Arduino.valueToCode(a, "ADD0", Blockly.Arduino.ORDER_UNARY_POSTFIX) || '""') + ")", Blockly.Arduino.ORDER_UNARY_POSTFIX];
    var c;
    b = [];
    for (var d = 0; d < a.itemCount_; d++) c = Blockly.Arduino.valueToCode(a, "ADD" + d, Blockly.Arduino.ORDER_NONE), b[d] = "" == c ? '""' : "String(" + c + ")";
    b = b.join(" + ");
    return [b, Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_append = function (a) {
    var b = Blockly.Arduino.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = Blockly.Arduino.valueToCode(a, "TEXT", Blockly.Arduino.ORDER_UNARY_POSTFIX);
    return b + " += " + ("" == a ? '""' : "String(" + a + ")") + ";\n"
};
Blockly.Arduino.text_length = function (a) {
    return ["String(" + (Blockly.Arduino.valueToCode(a, "VALUE", Blockly.Arduino.ORDER_UNARY_POSTFIX) || '""') + ").length()", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_isEmpty = function (a) {
    var b = [];
    b.push("boolean " + Blockly.Arduino.DEF_FUNC_NAME + "(String msg) {");
    b.push("  if (msg.length() == 0) {");
    b.push("    return true;");
    b.push("  } else {");
    b.push("    return false;");
    b.push("  }");
    b.push("}");
    b = Blockly.Arduino.addFunction("isStringEmpty", b.join("\n"));
    a = Blockly.Arduino.valueToCode(a, "TEXT", Blockly.Arduino.ORDER_UNARY_POSTFIX);
    return [b + "(" + ("" == a ? '""' : "String(" + a + ")") + ")", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_trim = function (a) {
    Blockly.Arduino.text_trim.OPERATORS = {
        LEFT: ".trim()",
        RIGHT: ".trim()",
        BOTH: ".trim()"
    };
    var b = a.getFieldValue("MODE"),
        b = Blockly.Arduino.text_trim.OPERATORS[b];
    a = Blockly.Arduino.valueToCode(a, "TEXT", Blockly.Arduino.ORDER_UNARY_POSTFIX);
    return [("" == a ? '""' : "String(" + a + ")") + b, Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_print = function (a) {
    var b = Blockly.Arduino.Boards.selected.serial[0][1];
    Blockly.Arduino.addSetup("serial_" + b, b + ".begin(9600);", !1);
    a = Blockly.Arduino.valueToCode(a, "TEXT", Blockly.Arduino.ORDER_NONE);
    return b + ".print(" + ("" == a ? '""' : "String(" + a + ")") + ");\n"
};
Blockly.Arduino.text_prompt_ext = function (a) {
    var b = Blockly.Arduino.Boards.selected.serial[0][1],
        c = a.getFieldValue("TYPE"),
        d = [],
        e = c == Blockly.Types.NUMBER.output;
    e ? d.push("int " + Blockly.Arduino.DEF_FUNC_NAME + "(String msg) {") : d.push("String " + Blockly.Arduino.DEF_FUNC_NAME + "(String msg) {");
    d.push("  " + b + ".println(msg);");
    d.push("  boolean stringComplete = false;");
    e ? d.push("  int content = 0;") : d.push('  String content = "";');
    d.push("  while (stringComplete == false) {");
    d.push("    if (" + b + ".available()) {");
    e ? (d.push("      content = " + b + ".parseInt();"), d.push("      stringComplete = true;")) : (d.push("      char readChar = (char)" + b + ".read();"), d.push("      if (readChar == '\\n' || readChar == '\\r') {"), d.push("        stringComplete = true;"), d.push("      } else {"), d.push("        content += readChar;"), d.push("      }"));
    d.push("    }");
    d.push("  }");
    d.push("  // Empty incoming serial buffer");
    d.push("  while(Serial.available()) { Serial.read(); };");
    d.push("  return content;");
    d.push("}");
    c = Blockly.Arduino.addFunction("getUserInputPrompt" +
        c, d.join("\n"));
    Blockly.Arduino.addSetup("serial_" + b, b + ".begin(9600);", !1);
    a = Blockly.Arduino.valueToCode(a, "TEXT", Blockly.Arduino.ORDER_NONE) || '""';
    return [c + "(" + a + ")", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_changeCase = function (a) {
    var text = Blockly.Arduino.valueToCode(a, "TEXT", Blockly.Arduino.ORDER_NONE);
    var maj = a.getFieldValue("CASE")
    var code;
    switch (maj) {
        case "UPPER":
            code = ".toUpperCase()";
            break;
        case "LOWER":
            code = ".toLowerCase()";
            break;
        default:
            code = "";
    }
    return [text + code, Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.text_endString = function () {
    return ["", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_indexOf = function () {
    return ["", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_charAt = function () {
    return ["", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_getSubstring = function () {
    return ["", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_prompt = function () {
    return ["", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.text_comment = function () {
    return "//" + this.getFieldValue("string") + NEWLINE || "" + NEWLINE;
};

/////////////////////////////////////////////// VARIABLES CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.variables_get = function () {
    return [Blockly.Arduino.variableDB_.getName(this.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE), Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.variables_set = function (a) {
    let b = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ASSIGNMENT) || "0";
    let c = a.inputList[0].connection.targetBlock();
    if (c && (c.type == 'lists_create_with' || c.type == 'lists_repeat')){
        let d = Blockly.Types.CHILD_BLOCK_MISSING;
        let child = c.childBlocks_[0];
        if (c.type == 'lists_create_with') c = c.inputList.length;
        if (c.type == 'lists_repeat') c = Blockly.Arduino.valueToCode(c, "NUM", Blockly.Arduino.ORDER_ATOMIC);
        if (child && child.outputConnection && child.outputConnection) {
            // if child is a "normal" block
            if (child.outputConnection.check_){
                d = child.outputConnection.check_[0];
                d = Blockly.Types.getValidTypeWithId(d);
            // if child is a 'variable'
            }else if (child.type == 'variables_get') {
                for (let variable of Object.entries(Blockly.Arduino.StaticTyping.varTypeDict)) {
                    if (child.inputList[0].fieldRow[0].text_ == variable[0]) {
                        d = Blockly.Types.getValidTypeWithId(variable[1].typeId);
                    }
                };
            }
        }
        return Blockly.Arduino.getArduinoType_(d) + " " + Blockly.Arduino.variableDB_.getName(this.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE) + "[" + c + "] " + " = " + b + ";" + NEWLINE;
    }
    return Blockly.Arduino.variableDB_.getName(this.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE) + " = " + b + ";" + NEWLINE;
};
Blockly.Arduino.variables_set_type = function () {
    var b = Blockly.Arduino.valueToCode(this, "VARIABLE_SETTYPE_INPUT", Blockly.Arduino.ORDER_ASSIGNMENT) || "0";
    return ["(" + Blockly.Arduino.getArduinoType_(Blockly.Types[this.getFieldValue("VARIABLE_SETTYPE_TYPE")]) + ")(" + b + ")", Blockly.Arduino.ORDER_ATOMIC]
};

/////////////////////////////////////////////// LISTS CODE GENERATION BLOCKS ///////////////////////////////////////////////
Blockly.Arduino.lists_get_type = function () {
    return [this.getFieldValue("VAR"), Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.lists_create_empty = function () {
    return ["{}", Blockly.Arduino.ORDER_ATOMIC];
};
Blockly.Arduino.lists_create_with = function () {
    for (var b = Array(this.itemCount_), c = 0; c < this.itemCount_; c++) {
        b[c] = Blockly.Arduino.valueToCode(this, "ADD" + c, Blockly.Arduino.ORDER_NONE) || "0";
    }
    return ["{" + b.join(", ") + "}", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.lists_repeat = function () {
    var item = Blockly.Arduino.valueToCode(this, "ITEM", Blockly.Arduino.ORDER_ATOMIC) || "NULL";
    var num = Blockly.Arduino.valueToCode(this, "NUM", Blockly.Arduino.ORDER_ATOMIC) || "0";
    if (num < 1) num = 1;
    var code = "";
    for (var i = 0; i < num; i++) {
        if (i == num - 1) code += item;
        else code += item + ", ";
    }
    return ["{" + code + "}", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.lists_length = function () {
    var list = Blockly.Arduino.variableDB_.getName(this.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE) || 0;
    return ["sizeof(" + list + ")", Blockly.Arduino.ORDER_ATOMIC]
}
Blockly.Arduino.lists_isEmpty = Blockly.Arduino.noGeneratorCodeInline;
Blockly.Arduino.lists_indexOf = Blockly.Arduino.noGeneratorCodeInline;
Blockly.Arduino.lists_getIndex = Blockly.Arduino.noGeneratorCodeInline;
Blockly.Arduino.lists_setIndex = Blockly.Arduino.noGeneratorCodeLine;

/////////////////////////////////////////////// PROCEDURES CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.procedures_defreturn = function (a) {
    var b = Blockly.Arduino.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE),
        c = Blockly.Arduino.statementToCode(a, "STACK");
    Blockly.Arduino.STATEMENT_PREFIX && (c = Blockly.Arduino.prefixLines(Blockly.Arduino.STATEMENT_PREFIX.replace(/%1/g, "'" + a.id + "'"), Blockly.Arduino.INDENT) + c);
    Blockly.Arduino.INFINITE_LOOP_TRAP && (c = Blockly.Arduino.INFINITE_LOOP_TRAP.replace(/%1/g, "'" + a.id + "'") + c);
    var d = Blockly.Arduino.valueToCode(a, "RETURN", Blockly.Arduino.ORDER_NONE) ||
        "";
    d && (d = "  return " + d + ";\n");
    for (var e = [], f = 0; f < a.arguments_.length; f++) e[f] = Blockly.Arduino.getArduinoType_(a.getArgType(a.arguments_[f])) + " " + Blockly.Arduino.variableDB_.getName(a.arguments_[f], Blockly.Variables.NAME_TYPE);
    f = Blockly.Types.NULL;
    /**
     * CHANGES FOR RETURN PRODEDURES TYPING TO WORK
     */
    if (a.getReturnType == undefined) {
        for (let key of Object.entries(a.workspace.blockDB_)) {
            if (key[1].inputList[0].fieldRow[1]) {
                if ((key[1].inputList[0].fieldRow[1].text_ == a.inputList[0].fieldRow[1].text_) && (key[1].type == 'procedures_defreturn')) {
                    if (key[1].childBlocks_) {
                        let typeCheck = Blockly.Types.NULL.typeId;
                        key[1].childBlocks_.forEach(child => {
                            if (child.outputConnection) {
                                // IF THE CHILD IS A "NORMAL" BLOCK, WE GET ITS TYPE
                                if (child.outputConnection.check_) {
                                    typeCheck = child.outputConnection.check_[0];
                                    // IF THE CHILD IS A VARIABLE WE LOOK FOR ITS TYPE
                                } else if (child.type == 'variables_get') {
                                    for (let variable of Object.entries(Blockly.Arduino.StaticTyping.varTypeDict)) {
                                        if (child.inputList[0].fieldRow[0].text_ == variable[0]) {
                                            typeCheck = variable[1].typeId;
                                        }
                                    };
                                }
                            }
                        });
                        f = Blockly.Types.getValidTypeWithId(typeCheck);
                    }
                }
            }
        }
    }
    a.getReturnType && (f = a.getReturnType());
    f = Blockly.Arduino.getArduinoType_(f);
    c = f + " " + b + "(" + e.join(", ") + ") {" + NEWLINE + c + d + "}";
    c = Blockly.Arduino.scrub_(a, c);
    Blockly.Arduino.userFunctions_[b] = c;
    return null
};
Blockly.Arduino.procedures_defnoreturn = Blockly.Arduino.procedures_defreturn;
Blockly.Arduino.procedures_callreturn = function (a) {
    for (var b = Blockly.Arduino.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.Arduino.valueToCode(a, "ARG" + d, Blockly.Arduino.ORDER_NONE) || "null";
    return [b + "(" + c.join(", ") + ")", Blockly.Arduino.ORDER_UNARY_POSTFIX]
};
Blockly.Arduino.procedures_callnoreturn = function (a) {
    for (var b = Blockly.Arduino.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.Arduino.valueToCode(a, "ARG" + d, Blockly.Arduino.ORDER_NONE) || "null";
    return b + "(" + c.join(", ") + ");" + NEWLINE;
};
Blockly.Arduino.procedures_ifreturn = function (a) {
    var b = "if (" + (Blockly.Arduino.valueToCode(a, "CONDITION", Blockly.Arduino.ORDER_NONE) || "false") + ") {" + NEWLINE;
    a.hasReturnValue_ ? (a = Blockly.Arduino.valueToCode(a, "VALUE", Blockly.Arduino.ORDER_NONE) || "null", b += "  return " + a + ";" + NEWLINE) : b += "  return;" + NEWLINE;
    return b + "}" + NEWLINE;
};
Blockly.Arduino.arduino_functions = function (a) {
    var b = Blockly.Arduino.statementToCode(a, "SETUP_FUNC");
    b && Blockly.Arduino.addSetup("userSetupCode", b, !0);
    a = a.getInputTargetBlock("LOOP_FUNC");
    b = Blockly.Arduino.blockToCode(a);
    if (!goog.isString(b)) throw 'Expecting code from statement block "' + a.type + '".';
    return b;
};

/////////////////////////////////////////////// BEGIN CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.forever = function () {
    var d = Blockly.Arduino.statementToCode(this, "DO");
    d = Blockly.Arduino.addLoopTrap(d, this.id);
    var splitted = d.match(/[^\r\n]+/g);
    if (splitted != null) {
        splitted.forEach(element => {
            Blockly.Arduino.addLoopFunc(i, element);
            ++i;
        });
    }
    return null;
};
Blockly.Arduino.on_start = function () {
    var c = Blockly.Arduino.statementToCode(this, "DO");
    c = Blockly.Arduino.addLoopTrap(c, this.id);
    var splitted = c.match(/[^\r\n]+/g);
    if (splitted != null) {
        splitted.forEach(element => {
            Blockly.Arduino.addSetupFunc(i, element);
            ++i;
        });
    }
    return null;
};

/////////////////////////////////////////////// DISPLAY CODE GENERATION BLOCKS ///////////////////////////////////////////////

// GROVE LCD RGB _ SET TEXT BLOCK 
Blockly.Arduino.display_lcdRGBSetText = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_rgb_lcd', INCLUDE_RGB_LCD);
    Blockly.Arduino.addDeclaration('init_rgb_lcd', "rgb_lcd lcdRgb;");
    var txt = Blockly.Arduino.valueToCode(this, "TEXT", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addSetup("setup_rgb_lcd", "lcdRgb.begin(16, 2);");
    return "lcdRgb.setCursor(0, " + this.getFieldValue("line") + ");" + NEWLINE + "lcdRgb.print(String(" + txt + "));" + NEWLINE;
};
// GROVE LCD RGB _ SET COLOR BLOCK
Blockly.Arduino.display_lcdRGBSetColor = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_rgb_lcd', INCLUDE_RGB_LCD);
    Blockly.Arduino.addDeclaration('init_rgb_lcd', "rgb_lcd lcdRgb;");
    Blockly.Arduino.addSetup("setup_rgb_lcd", "lcdRgb.begin(16, 2);");
    let r = Blockly.Arduino.valueToCode(this, "R", Blockly.Arduino.ORDER_ATOMIC);
    if (r < 0) r = 0;
    if (r > 255) r = 255;
    let g = Blockly.Arduino.valueToCode(this, "G", Blockly.Arduino.ORDER_ATOMIC);
    if (g < 0) g = 0;
    if (g > 255) g = 255;
    let b = Blockly.Arduino.valueToCode(this, "B", Blockly.Arduino.ORDER_ATOMIC);
    if (b < 0) b = 0;
    if (b > 255) b = 255;
    return "lcdRgb.setRGB(" + r + ", " + g + ", " + b + ");" + NEWLINE;
};
// GROVE LCD RGB _ SET COLOR BLOCK
Blockly.Arduino.display_lcdRGBSetPaletteColor = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_rgb_lcd', INCLUDE_RGB_LCD);
    Blockly.Arduino.addDeclaration('init_rgb_lcd', "rgb_lcd lcdRgb;");
    Blockly.Arduino.addSetup("setup_rgb_lcd", "lcdRgb.begin(16, 2);");
    var colour = Blockly.Arduino.valueToCode(this, "COLOR", Blockly.Arduino.ORDER_NONE) || "0, 0, 0";
    return "lcdRgb.setRGB(" + colour + ");" + NEWLINE;
};
// GROVE LCD RGB _ CLEAR SCREEN BLOCK
Blockly.Arduino.display_lcdRGBClear = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_rgb_lcd', INCLUDE_RGB_LCD);
    Blockly.Arduino.addDeclaration('init_rgb_lcd', "rgb_lcd lcdRgb;");
    Blockly.Arduino.addSetup("setup_rgb_lcd", "lcdRgb.begin(16, 2);");
    return "lcdRgb.clear();" + NEWLINE;
};
// GROVE OLED DISPLAY _ SET TEXT BLOCK
Blockly.Arduino.display_addOledText = function () {
    let x = Blockly.Arduino.valueToCode(this, "X", Blockly.Arduino.ORDER_ATOMIC);
    let y = Blockly.Arduino.valueToCode(this, "Y", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_seeed_oled', INCLUDE_SEEED_OLED);
    Blockly.Arduino.addFunction('func_str_to_char', DEF_STRING_TO_CHAR);
    let text = Blockly.Arduino.valueToCode(this, "TEXT", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addSetup('setup_wire', "Wire.begin();");
    Blockly.Arduino.addSetup("setup_seeed_oled", "SeeedOled.init();");
    var set = "SeeedOled.clearDisplay();" + NEWLINE;
    set += "SeeedOled.setNormalDisplay();" + NEWLINE;
    set += "SeeedOled.setPageMode();" + NEWLINE;
    Blockly.Arduino.addSetup('set_seed_oled', set);
    return "SeeedOled.setTextXY(" + y + ", " + x + ");" + NEWLINE + "SeeedOled.putString(strToChar(String(" + text + ")));" + NEWLINE;
};
// GROVE OLED DISPLAY _ DRAW BITMAP LOGO
Blockly.Arduino.display_oledScreen_drawBitmapLogo = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_seeed_oled', INCLUDE_SEEED_OLED);
    Blockly.Arduino.addInclude('include_avr_pgmspace', INCLUDE_AVR_PGMSPACE);
    let logo = this.getFieldValue("LOGO");
    switch(logo) {
        case "vittascienceLogo":
            Blockly.Arduino.addDeclaration('bitmap_vittascience', BITMAP_VITTASCIENCE_LOGO);
            break;
        case "arduinoLogo":
        Blockly.Arduino.addDeclaration('bitmap_arduino', BITMAP_ARDUINO_LOGO);
            break;
        case "seeedLogo":
            Blockly.Arduino.addDeclaration('bitmap_seeed', BITMAP_SEEED_LOGO);
            break;
        case "microbitLogo":
            Blockly.Arduino.addDeclaration('bitmap_microbit', BITMAP_MICROBIT_LOGO);
            break;
    }
    Blockly.Arduino.addSetup('setup_wire', "Wire.begin();");
    Blockly.Arduino.addSetup("setup_seeed_oled", "SeeedOled.init();");
    return "SeeedOled.clearDisplay();" + NEWLINE + "SeeedOled.drawBitmap((unsigned char*)" + logo + ", 1024);" + NEWLINE;
};
// GROVE OLED DISPLAY _ DRAW BITMAP
Blockly.Arduino.display_clearOledScreen = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_seeed_oled', INCLUDE_SEEED_OLED);
    Blockly.Arduino.addSetup('setup_wire', "Wire.begin();");
    Blockly.Arduino.addSetup("setup_seeed_oled", "SeeedOled.init();");
    return "SeeedOled.clearDisplay();" + NEWLINE;
};
// LED DIGITAL CONTROL BLOCK
Blockly.Arduino.display_setGroveSocketLed = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "digitalWrite(" + pin + ", " + state + ");" + NEWLINE;
};
// LED PWM CONTROL BLOCK
Blockly.Arduino.display_setLEDintensity = function () {
    var pin = this.getFieldValue("PIN");
    var value = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC) || 0;
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "analogWrite(" + pin + ", " + value + ");" + NEWLINE;
};
// GROVE CHAINABLE RGB LED CONTROL BLOCK
//http://wiki.seeedstudio.com/Grove-Chainable_RGB_LED/
Blockly.Arduino.display_defineChainableRGBLed = function () {
    var pinDIN = this.getFieldValue("DIN");
    let pinCIN = this.getFieldValue("CIN");
    Blockly.Arduino.addInclude('include_chainable_led', INCLUDE_CHAINABLE_LED);
    let n = Blockly.Arduino.valueToCode(this, "NLED", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addDeclaration('define_chainable_led', "#define NUM_LEDS  " + n);
    Blockly.Arduino.addDeclaration('init_chainable_led', "ChainableLED leds(" + pinCIN + ", " + pinDIN + ", NUM_LEDS);");
    Blockly.Arduino.addSetup("setup_chainable_led", "leds.init();");
    return "";
};
// GROVE CHAINABLE RGB LED CONTROL BLOCK
//http://wiki.seeedstudio.com/Grove-Chainable_RGB_LED/
Blockly.Arduino.display_setColorChainableRGBLed = function () {
    Blockly.Arduino.addInclude('include_chainable_led', INCLUDE_CHAINABLE_LED);
    let led = Blockly.Arduino.valueToCode(this, "LED", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addDeclaration('define_chainable_led', "#define NUM_LEDS  1");
    Blockly.Arduino.addDeclaration('init_chainable_led', "ChainableLED leds(7, 8, NUM_LEDS);");
    let red = Blockly.Arduino.valueToCode(this, "R", Blockly.Arduino.ORDER_ATOMIC);
    if (red < 0) red = 0;
    if (red > 255) red = 255;
    let green = Blockly.Arduino.valueToCode(this, "G", Blockly.Arduino.ORDER_ATOMIC);
    if (green < 0) green = 0;
    if (green > 255) green = 255;
    let blue = Blockly.Arduino.valueToCode(this, "B", Blockly.Arduino.ORDER_ATOMIC);
    if (blue < 0) blue = 0;
    if (blue > 255) blue = 255;
    Blockly.Arduino.addSetup("setup_chainable_led", "leds.init();");
    return "leds.setColorRGB(" + led + ", " + red + ", " + green + ", " + blue + ");" + NEWLINE;
};
// GROVE CHAINABLE PALETTE RGB LED CONTROL BLOCK
//http://wiki.seeedstudio.com/Grove-Chainable_RGB_LED/
Blockly.Arduino.display_setPaletteColorChainableRGBLed = function () {
    Blockly.Arduino.addInclude('include_chainable_led', INCLUDE_CHAINABLE_LED);
    Blockly.Arduino.addDeclaration('define_chainable_led', "#define NUM_LEDS  1");
    Blockly.Arduino.addDeclaration('init_chainable_led', "ChainableLED leds(7, 8, NUM_LEDS);");
    let colour = Blockly.Arduino.valueToCode(this, "COLOR", Blockly.Arduino.ORDER_NONE) || "0, 0, 0";
    Blockly.Arduino.addSetup("setup_chainable_led", "leds.init();");
    return "leds.setColorRGB(0, " + colour + ");" + NEWLINE;
};
// GROVE NEOPIXEL - SET LED COLOR
Blockly.Arduino.display_controlNeopixelLed = function () {
    Blockly.Arduino.addInclude('include_neopixel', INCLUDE_ADAFRUIT_NEOPIXEL);
    Blockly.Arduino.addDeclaration('declare_led_count', "#define LED_COUNT   30");
    Blockly.Arduino.addDeclaration('init_neopixel', "Adafruit_NeoPixel Neopixel(LED_COUNT, " + this.getFieldValue("PIN") + ", NEO_GRB + NEO_KHZ800);");
    Blockly.Arduino.addSetup('setup_neopixel', "Neopixel.begin();");
    var led = Blockly.Arduino.valueToCode(this, "LED", Blockly.Arduino.ORDER_NONE) || 0;
    var r = Blockly.Arduino.valueToCode(this, "R", Blockly.Arduino.ORDER_NONE) || 0;
    var g = Blockly.Arduino.valueToCode(this, "G", Blockly.Arduino.ORDER_NONE) || 0;
    var b = Blockly.Arduino.valueToCode(this, "B", Blockly.Arduino.ORDER_NONE) || 0;
    if (r > 255) r = 255;
    if (r < 0) r = 0;
    if (g > 255) g = 255;
    if (g < 0) g = 0;
    if (b > 255) b = 255;
    if (b < 0) b = 0;
    return "Neopixel.setPixelColor(" + led + ", Neopixel.Color(" + r + ", " + g + ", " + b + "));" + NEWLINE + "Neopixel.show();" + NEWLINE;
};
// GROVE NEOPIXEL - SET LED COLOR (with 'palette')
Blockly.Arduino.display_controlColorNeopixelLed = function () {
    Blockly.Arduino.addInclude('include_neopixel', INCLUDE_ADAFRUIT_NEOPIXEL);
    Blockly.Arduino.addDeclaration('declare_led_count', "#define LED_COUNT   30");
    Blockly.Arduino.addDeclaration('init_neopixel', "Adafruit_NeoPixel Neopixel(LED_COUNT, " + this.getFieldValue("PIN") + ", NEO_GRB + NEO_KHZ800);");
    Blockly.Arduino.addSetup('setup_neopixel', "Neopixel.begin();");
    var led = Blockly.Arduino.valueToCode(this, "LED", Blockly.Arduino.ORDER_NONE) || 0;
    var colour = Blockly.Arduino.valueToCode(this, "COLOR", Blockly.Arduino.ORDER_NONE) || "0, 0, 0";
    return "Neopixel.setPixelColor(" + led + ", Neopixel.Color(" + colour + ");" + NEWLINE + "Neopixel.show();" + NEWLINE;
};
// GROVE NEOPIXEL - SET RAINBOW
Blockly.Arduino.display_rainbowNeopixel = function () {
    Blockly.Arduino.addInclude('include_neopixel', INCLUDE_ADAFRUIT_NEOPIXEL);
    var led = Blockly.Arduino.valueToCode(this, "LED", Blockly.Arduino.ORDER_NONE) || 0;
    Blockly.Arduino.addDeclaration('declare_led_count', "#define LED_COUNT   " + led);
    Blockly.Arduino.addDeclaration('init_neopixel', "Adafruit_NeoPixel Neopixel(LED_COUNT, " + this.getFieldValue("PIN") + ", NEO_GRB + NEO_KHZ800);");
    Blockly.Arduino.addSetup('setup_neopixel', "Neopixel.begin();");
    Blockly.Arduino.addFunction('func_show_np', DEF_SHOW_NEOPIXEL);
    Blockly.Arduino.addFunction('func_rainbow', DEF_NEOPIXEL_RAINBOW);
    return "rainbow();" + NEWLINE;
};
// GROVE 4-DIGIT DISPLAY TM1637 _ WRITE INTEGER
// http://wiki.seeedstudio.com/Grove-4-Digit_Display/
Blockly.Arduino.display_setNumberGrove4Digit = function () {
    let pinCLK = this.getFieldValue("CLK");
    let pinDIO = this.getFieldValue("DIO");
    Blockly.Arduino.addInclude('include_tm1637', INCLUDE_TM1637);
    Blockly.Arduino.addDeclaration('init_tm1637', "TM1637 tm1637(" + pinCLK + ", " + pinDIO + ");");
    Blockly.Arduino.addSetup("init_tm1637", "tm1637.init();");
    Blockly.Arduino.addSetup("set_tm1637", "tm1637.set(7); //Maximum brightness");
    let valeur = Blockly.Arduino.valueToCode(this, "N", Blockly.Arduino.ORDER_ATOMIC);
    if (valeur < -999) valeur = -999;
    if (valeur > 9999) valeur = 9999;
    return "tm1637.displayNum(" + valeur + ");" + NEWLINE;
};
Blockly.Arduino.display_setClockGrove4Digit = function () {
    let date = new Date();
    let pinCLK = this.getFieldValue("CLK");
    let pinDIO = this.getFieldValue("DIO");
    Blockly.Arduino.addInclude('include_tm1637', INCLUDE_TM1637);
    Blockly.Arduino.addDeclaration('init_tm1637', "TM1637 tm1637(" + pinCLK + ", " + pinDIO + ");");
    Blockly.Arduino.addDeclaration('const_chronometerClock', "int chrono0Clk = 0;" + NEWLINE
        + "//Warning, the clock is retrieved by browser when arduino code is uploaded." + NEWLINE
        + "//If arduino is powered off, time will not flow." + NEWLINE
        + "const uint8_t MIN_START = " + date.getMinutes() + ";" + NEWLINE
        + "const uint8_t HOUR_START = " + date.getHours() + ";");
    Blockly.Arduino.addSetup("init_tm1637", "tm1637.init();");
    Blockly.Arduino.addSetup("set_tm1637", "tm1637.set(7); //Maximum brightness");
    Blockly.Arduino.addFunction('func_tm1637_set_time', DEF_4DIGIT_SET_TIME);
    return "setTime_4Digit();" + NEWLINE;
};
// GROVE LED BAR _ CONTROL BLOCK
// http://wiki.seeedstudio.com/Grove-LED_Bar/
Blockly.Arduino.display_setLevelLedBar = function () {
    let pinDI = this.getFieldValue("DI");
    let pinDCKI = this.getFieldValue("DCKI");
    var value = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addInclude('include_led_bar', INCLUDE_GROVE_LED_BAR);
    Blockly.Arduino.addSetup('init_led_bar', "Grove_LED_Bar bar(" + pinDI + ", " + pinDCKI + ", 0);");
    Blockly.Arduino.addDeclaration("setup_led_bar", "bar.begin();");
    return "bar.setLevel(" + value + ");" + NEWLINE;
};

/////////////////////////////////////////////// INPUT/OUTPUT CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.io_wait = function () {
    var wait = Blockly.Arduino.valueToCode(this, "NUM", Blockly.Arduino.ORDER_ATOMIC);
    wait = wait * this.getFieldValue("UNIT");
    return "delay(" + wait + ");" + NEWLINE;
};
Blockly.Arduino.io_initChronometer = function () {
    Blockly.Arduino.addDeclaration('declaration_init_chrono', "float t0 = 0;");
    return "t0 = millis();" + NEWLINE;
};
Blockly.Arduino.io_getChronometer = function () {
    Blockly.Arduino.addDeclaration('declaration_init_chrono', "float t0 = 0;");
    return ["(millis()-t0)/" + this.getFieldValue("UNIT"), Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.io_control_arduino_led = function () {
    Blockly.Arduino.addSetup('pin13', "pinMode(13, OUTPUT);", !1);
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    return "digitalWrite(13, " + state + ");" + NEWLINE;
};
// GROVE KEYPAD _ READ VALUE BLOCK ON PIN A BLOCK
//http://wiki.seeedstudio.com/Grove-12-Channel-Capacitive-Touch-Keypad-ATtiny1616-/
Blockly.Arduino.io_getKeypadNumber = function () {
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    let pinRX = this.getFieldValue("RX");
    let pinTX = this.getFieldValue("TX");
    Blockly.Arduino.addDeclaration('init_keypad', "SoftwareSerial keypad(" + pinRX + ", " + pinTX + ");");
    Blockly.Arduino.addDeclaration('def_keypad_number', "uint8_t number=0;");
    Blockly.Arduino.addFunction('func_get_keypad', DEF_KEYPAD_GETNUMBER);
    Blockly.Arduino.addSetup('setup_keypad', "keypad.begin(9600);");
    return ["getKeypadNumber()", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE THUMB JOYSTICK _ READ VALUE BLOCK ON PIN A BLOCK
// http://wiki.seeedstudio.com/Grove-Thumb_Joystick/ 
Blockly.Arduino.io_getGroveThumbJoystick = function () {
    let pin = this.getFieldValue("PIN");
    switch (this.getFieldValue("AXIS")) {
        case "X":
            Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
            return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC];
        case "Y":
            Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
            return ["analogRead(" + pin + " + 1)", Blockly.Arduino.ORDER_ATOMIC];
    }
};
// READ ANALOG POTENTIOMETER ON PIN A BLOCK
// http://wiki.seeedstudio.com/Grove-Slide_Potentiometer/
Blockly.Arduino.io_getGroveSlidePotentiometer = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE ROTARY ANGLE SENSOR _ READ VALUE BLOCK ON PIN A BLOCK
// http://wiki.seeedstudio.com/Grove-Rotary_Angle_Sensor/
Blockly.Arduino.io_getGroveRotaryAngle = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// READ TACTILE STATEMENT ON PIN D BLOCK
Blockly.Arduino.io_getGroveTactile = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// READ PUSH BUTTON STATEMENT ON PIN D BLOCK
Blockly.Arduino.io_getGroveButton = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// READ SWITCH STATEMENT VALUE ON PIN D BLOCK
Blockly.Arduino.io_getGroveSwitch = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.io_readDigitalPin = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.io_writeDigitalPin = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "digitalWrite(" + pin + ", " + state + ");" + NEWLINE;
};
Blockly.Arduino.io_readAnalogPin = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
Blockly.Arduino.io_writeAnalogPin = function () {
    let pin = this.getFieldValue("PIN");
    let value = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC) || '0';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    if (value < 0) value = 0;
    if (value > 255) value = 255;
    return "analogWrite(" + pin + ", " + value + ");" + NEWLINE;
};
Blockly.Arduino.io_setPwm = function () {
    let pin = this.getFieldValue("PIN");
    let cycle = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC) || '0';
    let value = Math.round(cycle * 255 / 100);
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "analogWrite(" + pin + ", " + value + ");" + NEWLINE;
};
Blockly.Arduino.io_pulse_in = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'HIGH';
    return ["pulseIn(" + pin + ", " + state + ")", Blockly.Arduino.ORDER_ATOMIC];
};
Blockly.Arduino.io_digital_signal = function () {
    return [this.getFieldValue("STATE"), Blockly.Arduino.ORDER_ATOMIC];
};

/////////////////////////////////////////////// COMMUNICATION CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.communication_serialWrite = function () {
    let baud = document.getElementById("baud");
    let str = Blockly.Arduino.valueToCode(this, "TEXT", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    return "Serial.println(" + str + ");" + NEWLINE;
};
Blockly.Arduino.communication_onSerialDataReceived = function () {
    let baud = document.getElementById("baud");
    let dtaVar = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC) || "''";
    let branchCode = Blockly.Arduino.statementToCode(this, 'DO');
    Blockly.Arduino.addVariable(dtaVar, 'String ' + dtaVar + ";");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    return "if (Serial.available()) {" + NEWLINE + '  ' + dtaVar + " = Serial.readString();" + NEWLINE + branchCode + "}" + NEWLINE;
};
Blockly.Arduino.communication_graphSerialWrite = function () {
    var baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    if (this.itemCount_ === 0)
        return '';
    var c, b = [];

    b[0] = "Serial.print(\"@Graph:\");\n";
    for (var d = 1; d < this.itemCount_ + 1; d++) {

        c = Blockly.Arduino.valueToCode(this, "ADD" + (d - 1), Blockly.Arduino.ORDER_NONE);
        if (c[c.length - 1] === '|') {
            c = c.substring(0, c.length - 1);
            let data = c.split(':');
            if (isNaN(data[1])) {
                b[d] = "Serial.print(\"" + data[0] + ":\");\nSerial.print(" + data[1] + ");\nSerial.print(\"|\");\n";
            } else
                b[d] = "Serial.print(\"" + c + "|\");\n";
        } else if (!isNaN(c) && c !== '') {
            b[d] = "Serial.print(\"" + c + "|\");\n";
        } else {
            b[d] = "Serial.print(" + c + ");\nSerial.print(\"|\");\n";
        }
    }
    b[d + 1] = "Serial.print(\"\\n\");\ndelay(50);\n";

    b = b.join('');
    return (b);
};
Blockly.Arduino.communication_graphSerialWrite_datasFormat = function () {
    var name = Blockly.Arduino.valueToCode(this, "NAME", Blockly.Arduino.ORDER_ATOMIC);
    var data = Blockly.Arduino.valueToCode(this, "DATA", Blockly.Arduino.ORDER_ATOMIC);
    if (name == "") name = '""';
    else if (data == "") data = '""';
    else {
        name = name.substring(1, name.length);
        name = name.substring(0, name.length - 1);
    }
    if (!isNaN(data)) {
        data = data.toString();
    }
    let syntax = name + ":" + data + "|";
    let code = syntax;
    // The original file from IDE used "Blockly.ORDER_ATOMIC" which is not defined so we replaced it by "Blockly.Arduino.ORDER_ATOMIC".
    return [code.toString(), Blockly.Arduino.ORDER_ATOMIC];
};
Blockly.Arduino.communication_playComputerMusic = function () {
    let baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    let note = this.getFieldValue("Note");
    return "Serial.println(\"@music:" + note + "|\");" + NEWLINE;
};
Blockly.Arduino.communication_playComputerFrequency = function () {
    let baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    let frequency = Blockly.Arduino.valueToCode(this, "FREQUENCY", Blockly.Arduino.ORDER_ATOMIC);
    return "Serial.println(\"@music:" + frequency + "|\");" + NEWLINE;
};
Blockly.Arduino.communication_stopComputerMusic = function () {
    let baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    return "Serial.println(\"@music:stop|\");" + NEWLINE;
};
Blockly.Arduino.communication_writeOpenLogSd = function () {
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    let pinRX = this.getFieldValue("RX");
    let pinTX = this.getFieldValue("TX");
    Blockly.Arduino.addDeclaration('init_openlog', "SoftwareSerial OpenLog(" + pinRX + ", " + pinTX + ");");
    Blockly.Arduino.addSetup('setup_openlog', "OpenLog.begin(4800);");
    var data = Blockly.Arduino.valueToCode(this, "DATA", Blockly.Arduino.ORDER_NONE) || "'datas error'";
    return "OpenLog.println(" + data + ");" + NEWLINE;
};
Blockly.Arduino.communication_SDWriteDataSPI = function () {
    let data = Blockly.Arduino.valueToCode(this, "DATA", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addInclude('include_sd', INCLUDE_SD);
    Blockly.Arduino.addInclude('include_spi', INCLUDE_SPI);
    Blockly.Arduino.addDeclaration('define_file_name', "const String fileName = \"test.txt\";");
    Blockly.Arduino.addDeclaration('define_file_sd', "File dataFile;");
    Blockly.Arduino.addFunction('func_setup_SD', DEF_SD_SPI_SETUP_CARD);
    Blockly.Arduino.addFunction('func_write_SD', DEF_SD_SPI_WRITE_DATA);
    var baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup('setup_SD_card', "setupSDcard(" + this.getFieldValue("CS") + ");");
    return "writeOnSDcard(" + data + ");" + NEWLINE;
};
//http://wiki.seeedstudio.com/Grove-Serial_Bluetooth/
Blockly.Arduino.communication_sendSerialBluetoothData = function () {
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    let pinTX = this.getFieldValue("TX");
    let pinRX = this.getFieldValue("RX");
    let dta = Blockly.Arduino.valueToCode(this, "TEXT", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addDeclaration('setup_serial_bt', "SoftwareSerial blueToothSerial(" + pinTX + ", " + pinRX + ");")
    Blockly.Arduino.addFunction('func_setupBluetooth', DEF_SETUP_BT_CONNECTION);
    Blockly.Arduino.addSetup('pin_RX', "pinMode(" + pinRX + ", OUTPUT);");
    Blockly.Arduino.addSetup('pin_TX', "pinMode(" + pinTX + ", INPUT);");
    Blockly.Arduino.addSetup("setup_bt", "setupBlueToothConnection();");
    return "blueToothSerial.print(String(" + dta + "));" + NEWLINE;
};
Blockly.Arduino.communication_onSerialBluetoothDataReceived = function () {
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    let pinTX = this.getFieldValue("TX");
    let pinRX = this.getFieldValue("RX");
    let dtaVar = Blockly.Arduino.valueToCode(this, "DATA", Blockly.Arduino.ORDER_ATOMIC) || "''";
    Blockly.Arduino.addVariable(dtaVar, 'String ' + dtaVar + ";");
    Blockly.Arduino.addDeclaration('setup_serial_bt', "SoftwareSerial blueToothSerial(" + pinTX + ", " + pinRX + ");");
    Blockly.Arduino.addFunction('func_setupBluetooth', DEF_SETUP_BT_CONNECTION);
    Blockly.Arduino.addSetup('pin_RX', "pinMode(" + pinRX + ", INPUT);");
    Blockly.Arduino.addSetup('pin_TX', "pinMode(" + pinTX + ", OUTPUT);");
    Blockly.Arduino.addSetup("setup_bt", "setupBlueToothConnection();");
    var branchCode = Blockly.Arduino.statementToCode(this, 'DO');
    return "if(blueToothSerial.available()) {" + NEWLINE + "  " + dtaVar + " = blueToothSerial.read();" + NEWLINE + branchCode + "}" + NEWLINE;
};
//https://howtomechatronics.com/tutorials/arduino/arduino-wireless-communication-nrf24l01-tutorial/
Blockly.Arduino.communication_sendRadioNRF24Data = function () {
    Blockly.Arduino.addInclude("include_spi", INCLUDE_SPI);
    Blockly.Arduino.addInclude("include_rf24", INCLUDE_RF24);
    Blockly.Arduino.addInclude("include_nrf24l01", INCLUDE_NRF24L01);
    let address = this.getFieldValue("ADDR") || 0;
    Blockly.Arduino.addDeclaration("declare_radio_address", "const byte address[6] = \"0000" + address + "\";");
    let pinCE = this.getFieldValue("CE");
    let pinCSN = this.getFieldValue("CSN");
    let channel = Blockly.Arduino.valueToCode(this, "CANAL", Blockly.Arduino.ORDER_ATOMIC) || 0;
    if (channel < 0) channel = 0;
    if (channel > 125) channel = 125;
    Blockly.Arduino.addDeclaration('setup_radio_nrf24', "RF24 radioNRF(" + pinCE + ", " + pinCSN + ");");
    Blockly.Arduino.addFunction('func_setup_nRF', DEF_RADIO_NRF24L01_WRITING);
    Blockly.Arduino.addSetup('setup_radio_nRF24', "setupRadioNRF24_writing(" + channel + ")");
    let data = Blockly.Arduino.valueToCode(this, "DATA", Blockly.Arduino.ORDER_ATOMIC) || 0;
    if (data === null || !data || data.length === 0) data = 0;
    return "const char sentPacket[] = String(" + data + ");" + NEWLINE + "radioNRF.write(&sentPacket, sizeof(sentPacket));" + NEWLINE;
};
//https://howtomechatronics.com/tutorials/arduino/arduino-wireless-communication-nrf24l01-tutorial/
Blockly.Arduino.communication_onRadioNRF24_dataReceived = function () {
    Blockly.Arduino.addInclude("include_spi", INCLUDE_SPI);
    Blockly.Arduino.addInclude("include_nrf24l01", INCLUDE_NRF24L01);
    Blockly.Arduino.addInclude("include_rf24", INCLUDE_RF24);
    let address = this.getFieldValue("ADDR") || 0;
    Blockly.Arduino.addDeclaration("declare_radio_address", "const byte address[6] = \"0000" + address + "\";");
    let pinCE = this.getFieldValue("CE");
    let pinCSN = this.getFieldValue("CSN");
    Blockly.Arduino.addDeclaration('setup_radio_nrf24', "RF24 radioNRF(" + pinCE + ", " + pinCSN + ");");
    let dtaVar = Blockly.Arduino.valueToCode(this, "DATA", Blockly.Arduino.ORDER_ATOMIC) || "''";
    Blockly.Arduino.addVariable(dtaVar, 'String ' + dtaVar + ";");
    Blockly.Arduino.addFunction('func_setupNRF', DEF_RADIO_NRF24L01_READING);
    let channel = Blockly.Arduino.valueToCode(this, "CANAL", Blockly.Arduino.ORDER_ATOMIC) || 0;
    Blockly.Arduino.addSetup("setup_NRF24", "setupRadioNRF24_reading(" + channel + ");");
    var branchCode = Blockly.Arduino.statementToCode(this, 'DO');
    return "if(radioNRF.available()) {" + NEWLINE + "  char text[32] = '';" + NEWLINE + "  radioNRF.read(&text, sizeof(text));" + NEWLINE + "  " + dtaVar + " = text;" + NEWLINE + branchCode + "}" + NEWLINE;
};
//http://wiki.seeedstudio.com/Grove-433MHz_Simple_RF_Link_Kit/
Blockly.Arduino.communication_sendRadio433mhzData = function () {
    let pin = this.getFieldValue("PIN");
    let dta = Blockly.Arduino.valueToCode(this, "TEXT", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addInclude('include_virtual_wire', INCLUDE_VIRTUAL_WIRE);
    Blockly.Arduino.addDeclaration('define_pin' + pin, "#define RF_TX_PIN " + pin);
    Blockly.Arduino.addSetup("setup_433_emitter", SETUP_RADIO_433_EMITTER);
    return "char *msg = String(" + dta + ");" + NEWLINE + "vw_send((uint8_t *)msg, strlen(msg));" + NEWLINE;
};
//http://wiki.seeedstudio.com/Grove-433MHz_Simple_RF_Link_Kit/
Blockly.Arduino.communication_onRadio433mhzDataReceived = function () {
    let pin = this.getFieldValue("PIN");
    let baud = document.getElementById("baud");
    let dtaVar = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC) || "''";
    let branchCode = Blockly.Arduino.statementToCode(this, 'DO');
    Blockly.Arduino.addInclude('include_virtual_wire', INCLUDE_VIRTUAL_WIRE);
    Blockly.Arduino.addVariable(dtaVar, 'String ' + dtaVar + ";");
    Blockly.Arduino.addDeclaration('define_pin' + pin, "#define RF_RX_PIN " + pin);
    Blockly.Arduino.addFunction('func_getRadioMessage', DEF_RADIO_433_GET_MESSAGE);
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup("setup_433_receiver", SETUP_RADIO_433_RECEIVER);
    return dtaVar + " = get433RadioMessage();" + NEWLINE + "if (" + dtaVar + ' != "") {' + NEWLINE + branchCode + "}" + NEWLINE;
};
//http://wiki.seeedstudio.com/Grove-GPS/
Blockly.Arduino.communication_onGPSDataReceived = function () {
    let pinRX = this.getFieldValue("RX");
    let pinTX = this.getFieldValue("TX");
    let baud = document.getElementById("baud");
    let dtaVar = Blockly.Arduino.valueToCode(this, "DATA", Blockly.Arduino.ORDER_ATOMIC) || "''";
    let branchCode = Blockly.Arduino.statementToCode(this, 'DO');
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    Blockly.Arduino.addDeclaration('init_gps', "SoftwareSerial gpsSerial(" + pinRX + ", " + pinTX + ");");
    Blockly.Arduino.addVariable('var_buffer_char', 'uint8_t buffer[64];');
    Blockly.Arduino.addVariable('var_count', 'int count = 0;');
    Blockly.Arduino.addVariable(dtaVar, 'String ' + dtaVar + ";");
    Blockly.Arduino.addFunction('func_clear_buffer', DEF_CLEAR_BUFFER_ARRAY);
    Blockly.Arduino.addFunction('func_getGPSdta', DEF_GPS_GET_DATA);
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup("setup_gps", SETUP_GPS);
    return "if (gpsSerial.available()) {" + NEWLINE + dtaVar + " = getGPSBuffer();" + NEWLINE + branchCode + "}" + NEWLINE;
};

// GROVE RTC _ INIT SET DAY BLOCK
//http://wiki.seeedstudio.com/Grove-RTC/
Blockly.Arduino.communication_clockRTC_setDay = function () {
    Blockly.Arduino.addInclude('include_ds1307', INCLUDE_DS1307);
    Blockly.Arduino.addDeclaration('init_ds1307', "DS1307 clock;");
    let year = Blockly.Arduino.valueToCode(this, "YEAR", Blockly.Arduino.ORDER_ATOMIC);
    let month = Blockly.Arduino.valueToCode(this, "MONTH", Blockly.Arduino.ORDER_ATOMIC);
    if (month < 1) month = 1;
    if (month > 12) month = 12;
    let day_nb = Blockly.Arduino.valueToCode(this, "MONTH_DAY", Blockly.Arduino.ORDER_ATOMIC);
    if (day_nb < 1) day_nb = 1;
    if (day_nb > 31) day_nb = 31;
    Blockly.Arduino.addSetup("setup_ds1307", "clock.begin();");
    Blockly.Arduino.addSetup("setup_ds1307_YMD", "clock.fillByYMD(" + year + "," + month + "," + day_nb + ");");
    Blockly.Arduino.addSetup("setup_ds1307_fill", "clock.fillDayOfWeek(" + this.getFieldValue("DAY") + ");");
    Blockly.Arduino.addSetup("setup_set_date", "clock.setTime();");
    return "";
};
// GROVE RTC _ INIT SET HOUR BLOCK
//http://wiki.seeedstudio.com/Grove-RTC/
Blockly.Arduino.communication_clockRTC_setHour = function () {
    Blockly.Arduino.addInclude('include_ds1307', INCLUDE_DS1307);
    Blockly.Arduino.addDeclaration('init_ds1307', "DS1307 clock;");
    let hour = Blockly.Arduino.valueToCode(this, "HOUR", Blockly.Arduino.ORDER_ATOMIC);
    if (hour < 0) hour = 0;
    if (hour > 23) hour = 23;
    let minute = Blockly.Arduino.valueToCode(this, "MIN", Blockly.Arduino.ORDER_ATOMIC);
    if (minute < 0) minute = 0;
    if (minute > 59) minute = 59;
    let second = Blockly.Arduino.valueToCode(this, "SEC", Blockly.Arduino.ORDER_ATOMIC);
    if (second < 0) second = 0;
    if (second > 59) second = 59;
    Blockly.Arduino.addSetup("setup_ds1307", "clock.begin();");
    Blockly.Arduino.addSetup("setup_ds1307_HMS", "clock.fillByHMS(" + hour + "," + minute + "," + second + ");");
    Blockly.Arduino.addSetup("setup_set_time", "clock.setTime();");
    return "";
};
// GROVE RTC _ READ TIME BLOCK
//http://wiki.seeedstudio.com/Grove-RTC/
Blockly.Arduino.communication_clockRTC_readTime = function () {
    Blockly.Arduino.addInclude('include_ds1307', INCLUDE_DS1307);
    Blockly.Arduino.addDeclaration('init_ds1307', "DS1307 clock;");
    Blockly.Arduino.addSetup("setup_ds1307", "clock.begin();");
    let dta = this.getFieldValue("DATA");
    if (parseInt(dta, 10) < 6) {
        Blockly.Arduino.addFunction('func_get_clock', DEF_RTC_GET_CLOCK);
        return ["getClockRTC(" + dta + ")", Blockly.Arduino.ORDER_ATOMIC];
    } else {
        Blockly.Arduino.addFunction('func_get_day', DEF_RTC_GET_DAY_NAME);
        return ['getDayNameRTC()', Blockly.Arduino.ORDER_ATOMIC];
    }
};
//http://wiki.seeedstudio.com/Grove-125KHz_RFID_Reader/
Blockly.Arduino.communication_rfid_getCardID = function () {
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    let pinRX = this.getFieldValue("RX");
    let pinTX = this.getFieldValue("TX");
    Blockly.Arduino.addDeclaration('define_serial_rfid', "SoftwareSerial rfid(" + pinRX + ", " + pinTX + ");");
    Blockly.Arduino.addDeclaration('var_buffer_byte', "byte buffer[64];");
    Blockly.Arduino.addDeclaration('var_count', "int count = 0;");
    Blockly.Arduino.addFunction('func_clear_buffer', DEF_CLEAR_BUFFER_ARRAY);
    Blockly.Arduino.addFunction('func_rfid_get_id', DEF_RFID_GET_STRING_CARD_ID);
    Blockly.Arduino.addSetup("setup_rfid", "rfid.begin(9600);");
    return ['getStringCardID()', Blockly.Arduino.ORDER_ATOMIC];
};
/*
//http://duinoedu.com/store1/-bluetooth/293-hc05.html
Blockly.Arduino.vitta_grove_hc05 = function () {
    var pin = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC);
    let pin2 = eval(pin) + eval(1);
    Blockly.Arduino.addInclude('include_rgb_lcd', INCLUDE_RGB_LCD);
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    Blockly.Arduino.addInclude('include_kd_class3', "#include <KD-CLASS-3.h>");
    Blockly.Arduino.addInclude('setup_bluetooth', "SoftwareSerial blueToothSerial_" + pin + "(" + pin + ", " + pin2 + ");");
    Blockly.Arduino.addInclude('define_hc05.h_3', "int blueToothReceiveData() {\n");
    Blockly.Arduino.addInclude('define_hc05.h_3', "if(blueToothSerial_"+pin+".available())return blueToothSerial_"+pin+".read();\n");
    Blockly.Arduino.addInclude('define_hc05.h_3', "else return 256;\n}");
    Blockly.Arduino.addDeclaration('init_rgb_lcd', "rgb_lcd lcdRgb;");
    Blockly.Arduino.addSetup("setup_print", "blueToothSerial_"+pin+".begin(9600);");
    Blockly.Arduino.addSetup("setup_rgb_lcd", "lcdRgb.begin(16, 2);");
    Blockly.Arduino.addSetup("setup_print", "lcdRgb.setCursor(0,0);");
    Blockly.Arduino.addSetup("setup_print", "lcdRgb.print(blueToothReceiveData());\n}");
        return ["_loop();", Blockly.Arduino.ORDER_ATOMIC] 
};

//http://wiki.seeedstudio.com/Grove-Infrared_Receiver/
Blockly.Arduino.vitta_grove_infrared_receiver = function () {
    var pin = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addInclude('define_hc05.h_8', "#include <IRSendRev.h>");
    Blockly.Arduino.addInclude('define_hc05.h', "#define BIT_LEN 0");
    Blockly.Arduino.addInclude('define_hc05.h_2', "#define BIT_START_H 1");
    Blockly.Arduino.addInclude('define_hc05.h_3', "#define BIT_START_L 2");
    Blockly.Arduino.addInclude('define_hc05.h_4', "#define BIT_DATA_H 3");
    Blockly.Arduino.addInclude('define_hc05.h_5', "#define BIT_DATA_L 4");
    Blockly.Arduino.addInclude('define_hc05.h_6', "#define BIT_DATA_LEN 5");
    Blockly.Arduino.addInclude('define_hc05.h_7', "#define BIT_DATA 6");
    Blockly.Arduino.addInclude('define_hc05.h_9', "const int pinRecv = 2;");
    let unit = this.getFieldValue("grove_infrared_receiver");
    Blockly.Arduino.addSetup("setup_print", "Serial.begin(115200);");
    Blockly.Arduino.addSetup("setup_print", "IR.Init(pinRecv);");
    Blockly.Arduino.addSetup("setup_print", "unsigned char dta[20];");
    var code = "if(IR.IsDta()){\n";
        code += "IR.Recv(dta);\n";
        code += "for(int i=0; i<dta[BIT_DATA_LEN]; i++)\n{\n";
        code += "Serial.print('0x');\n";
        code += "Serial.print(dta[i+BIT_DATA], HEX);\n}\n";
        code += "for(int i=0; i<dta[BIT_DATA_LEN]; i++)\n{\n";
        code += "Serial.print(dta[i+BIT_DATA], DEC);\n}\n";
        code += "Serial.println()\n}"
        return [code, Blockly.Arduino.ORDER_ATOMIC] 
};
*/
/////////////////////////////////////////////// SENSORS CODE GENERATION BLOCKS ///////////////////////////////////////////////

// READ DURATION PROGRAM BLOCK
Blockly.Arduino.communication_readTimeClockRTC = function () {
    return ["millis() / 1000", Blockly.Arduino.ORDER_ATOMIC]
};

// SGP30 SENSOR _ CO2/TVOC BLOCK
Blockly.Arduino.sensors_getSgp30Gas = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_adafruit_sgp30', INCLUDE_ADAFRUIT_SGP30);
    Blockly.Arduino.addDeclaration('init_sgp30', "Adafruit_SGP30 sgp30;");
    let baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup('setup_sgp30_check', "if(!sgp30.begin()) {\n\tSerial.println(\"SGP30 non trouvé..\");\n\twhile (1);}");
    switch (this.getFieldValue("GAS")) {
        case "0":
            Blockly.Arduino.addFunction('func_getCO2', DEF_SGP30_GET_CO2);
            return ['getCO2()', Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            Blockly.Arduino.addFunction('func_getTVOC', DEF_SGP30_GET_TVOC);
            return ['getTVOC()', Blockly.Arduino.ORDER_ATOMIC];
    }
};
// MULTICHANNEL GAS SENSOR _ READ GAS BLOCK
Blockly.Arduino.sensors_getMultichannelGas = function () {
    Blockly.Arduino.addInclude('include_multichannel_gas_sensor', INCLUDE_MULTICHANNEL_GAS_SENSOR);
    Blockly.Arduino.addSetup('setup_multi_gas_begin', "gas.begin(0x04);");
    Blockly.Arduino.addSetup('setup_multi_gas_power', "gas.powerOn();");
    return ["gas.measure_" + this.getFieldValue("GAS") + "()", Blockly.Arduino.ORDER_ATOMIC]
};
// O2 GAS SENSOR _ READ O2 BLOCK
Blockly.Arduino.sensors_getO2gas = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addDeclaration("define_O2_settings", DECLARE_O2_GAS);
    Blockly.Arduino.addDeclaration('pin_' + pin, "const int pinAdc = " + pin + ";");
    switch (this.getFieldValue("DATA")) {
        case "0":
            Blockly.Arduino.addFunction("func_getO2Vout", DEF_O2_SENSOR_READ_VOUT);
            Blockly.Arduino.addFunction("func_getO2Concentration", DEF_O2_SENSOR_CONCENTRATION);
            return ['readConcentration()', Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            Blockly.Arduino.addFunction("func_getO2Vout", DEF_O2_SENSOR_READ_VOUT);
            return ['readO2Vout()', Blockly.Arduino.ORDER_ATOMIC];
    }
};
// MQ135 SENSOR _ CO2 BLOCK
Blockly.Arduino.sensors_getMq135gas = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, "pinMode(" + pin + ", INPUT);");
    return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// DUST SENSOR _ READ CONCENTRATION BLOCK
Blockly.Arduino.sensors_getDustConcentration = function () {
    let pin = this.getFieldValue("PIN");
    Blockly.Arduino.addDeclaration("define_dust_sampletime", "#define SAMPLETIME_MS   30000");
    Blockly.Arduino.addDeclaration("declare_starttime", "uint32_t starttime;");
    Blockly.Arduino.addFunction("func_getdust_concentration", DEF_DUST_GET_PARTICULATE_DATA);
    Blockly.Arduino.addSetup("setup_dust_pin", "pinMode(" + pin + ", INPUT);");
    Blockly.Arduino.addSetup("setup_dust_t0", "starttime = millis();");
    return ["readParticulate_dustSensor(" + pin + ", " + this.getFieldValue("DATA") + ")", Blockly.Arduino.ORDER_ATOMIC];
};
// GROVE LASER SENSOR (HM3301) - GET PARTICLE AMOUNT
// http://wiki.seeedstudio.com/Grove-Laser_PM2.5_Sensor-HM3301/
Blockly.Arduino.sensors_getParticulateMatter = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_seeed_hm330x', INCLUDE_SEEED_HM330X);
    Blockly.Arduino.addDeclaration('init_hm330x', "HM330X sensor;");
    Blockly.Arduino.addDeclaration('init_hm330x_buf', "uint8_t buf[30];");
    Blockly.Arduino.addDeclaration('init_hm330x_measure', "uint16_t measure;");
    var baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup('setup_hm330x_check', "if (sensor.init()) {\n\tSerial.println('HM330X init failed!!!');\n\twhile (1);\n}");
    Blockly.Arduino.addFunction("func_parse_result", DEF_HM330X_PARSE_RESULT);
    Blockly.Arduino.addFunction("func_get_hm330x_measure", DEF_HM330X_GET_MEASURE);
    return ["get_HM330X_measure(" + this.getFieldValue("TYPE") + ")", Blockly.Arduino.ORDER_ATOMIC];
};
// MHZ19 SENSOR _ GET CO2 AND TEMPERATURE BLOCK
Blockly.Arduino.sensors_getMhz19Data = function () {
    Blockly.Arduino.addInclude('include_software_serial', INCLUDE_SOFTWARE_SERIAL);
    let pinTX = this.getFieldValue("TX");
    let pinRX = this.getFieldValue("RX");
    Blockly.Arduino.addDeclaration('setup_ss_mhz', "SoftwareSerial s_serial_mhz(" + pinTX + ", " + pinRX + ");")
    Blockly.Arduino.addDeclaration('declare_mhz', DECLARE_MHZ19);
    Blockly.Arduino.addFunction('func_mhz_data', DEF_MHZ19_DATARECEIVE);
    Blockly.Arduino.addSetup("init_mhz", "mhz19.begin(9600);" + NEWLINE + "delay(2000);");
    switch (this.getFieldValue("DATA")) {
        case "0":
            Blockly.Arduino.addFunction('func_mhz_co2', DEF_MHZ19_GETCO2);
            return ["getMHZ19Co2()", Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            Blockly.Arduino.addFunction('func_mhz_temp', DEF_MHZ19_GETTEMP);
            return ["getMHZ19Temperature()", Blockly.Arduino.ORDER_ATOMIC];
    }
};
// BMP280 SENSOR _ READ TEMPERATURE/RESSURE/ALTITUDE BLOCK
Blockly.Arduino.sensors_getBmp280Data = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_adafruit_bmp280_i2c', INCLUDE_ADAFRUIT_BMP280);
    Blockly.Arduino.addDeclaration('init_bmp280', "Adafruit_BMP280 bmp280;");
    Blockly.Arduino.addDeclaration('init_bmp280_altitude', "float h0;");
    var baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup('setup_bmp280_check', "while (!bmp280.begin(" + this.getFieldValue("ADDR") + "))\n\tSerial.println(\"En attente du capteur...\");");
    switch (this.getFieldValue("DATA")) {
        case "0":
            return ['bmp280.readTemperature()', Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            return ['bmp280.readPressure()', Blockly.Arduino.ORDER_ATOMIC];
        case "2":
            Blockly.Arduino.addSetup('setup_bmp280_altitude', "delay(500);\nh0 = bmp280.readAltitude(1013.25);");
            return ['bmp280.readAltitude()-h0', Blockly.Arduino.ORDER_ATOMIC];
    }
};
// GROVE MOISTURE SENSOR _ READ VALUE BLOCK ON PIN A BLOCK
// http://wiki.seeedstudio.com/Grove-Moisture_Sensor/
Blockly.Arduino.sensors_getGroveMoisture = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, "pinMode(" + pin + ", INPUT);");
    return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE TEMPERATURE SENSOR _ READ VALUE BLOCK ON PIN A BLOCK
// http://wiki.seeedstudio.com/Grove-Temperature_Sensor/
Blockly.Arduino.sensors_getGroveTemperature = function () {
    Blockly.Arduino.addFunction('func_get_temp', DEF_GET_TEMP);
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["getTemperature(analogRead(" + pin + "))", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE TEMPERATURE SENSOR _ READ HIGH TEMPERATURE 
// http://wiki.seeedstudio.com/Grove-High_Temperature_Sensor/
Blockly.Arduino.sensors_getGroveHighTemperature = function () {
    var pinA0 = this.getFieldValue("A0");
    let pinA1 = this.getFieldValue("A1");
    Blockly.Arduino.addInclude('include_high_temp', INCLUDE_HIGH_TEMP);
    Blockly.Arduino.addDeclaration('init_high_temp', "HighTemp ht(" + pinA1 + ", " + pinA0 + ");");
    Blockly.Arduino.addSetup("setup_high_temp", "ht.begin();");
    return ["ht.getThmc()", Blockly.Arduino.ORDER_ATOMIC]
};
// DHT 11/22 SENSOR _ READ HUMIDITY BLOCK
Blockly.Arduino.sensors_dhtReadData = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_dht', INCLUDE_DHT);
    let pin = this.getFieldValue("PIN");
    let sensor = this.getFieldValue("SENSOR");
    Blockly.Arduino.addSetup("setup_dht", "dht.begin();");
    switch (sensor) {
        case "0":
            Blockly.Arduino.addDeclaration('declare_' + sensor, "DHT dht(" + pin + ", DHT11);");
            break;
        case "1":
            Blockly.Arduino.addDeclaration('declare_' + sensor, "DHT dht(" + pin + ", DHT22);");
            break;
    }
    switch (this.getFieldValue("VALUE")) {
        case "0":
            return ["dht.readTemperature()", Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            return ["dht.readHumidity()", Blockly.Arduino.ORDER_ATOMIC];
    }
};
// MPX5700AP SENSOR _ READ PRESSURE
//https://www.gotronic.fr/art-capteur-mpx5700ap-grove-110020248-30374.htm
Blockly.Arduino.sensors_mpx5700ap_getPressure = function () {
    Blockly.Arduino.addFunction('func_get_pressure', DEF_MPX5700AP_GET_PRESSURE);
    return ["getPressure_MPX5700(" + this.getFieldValue("PIN") + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// MAX6675 SENSOR _ READ TEMPERATURE BLOCK
Blockly.Arduino.sensors_getMax6675Temp = function () {
    Blockly.Arduino.addInclude('include_max6675', INCLUDE_MAX6675);
    let pinSO = this.getFieldValue("SO");
    let pinCS = this.getFieldValue("CS");
    let pinCLK = this.getFieldValue("CLK");
    Blockly.Arduino.addDeclaration('define_max6675', "int ktcSO = " + pinSO + ";" + NEWLINE + "int ktcCS = " + pinCS + ";" + NEWLINE + "int ktcCLK = " + pinCLK + ";" + NEWLINE);
    Blockly.Arduino.addDeclaration('init_max6675', "MAX6675 ktc(ktcCLK, ktcCS, ktcSO);");
    Blockly.Arduino.addSetup('setup_max6675', "delay(500); // Attention : wait at least 0,5 seconds between each measurements of max6675");
    let unit = this.getFieldValue("UNIT");
    return ["ktc.read" + unit + "()", Blockly.Arduino.ORDER_ATOMIC]
};
// BME680 SENSOR _ READ TEMPERATURE/RESSURE/HUMIDITY/GAS BLOCK
Blockly.Arduino.sensors_getBme680Data = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_seeed_bme680', INCLUDE_SEEED_BME680);
    Blockly.Arduino.addDeclaration('define_bme680_addr', "#define BME_IIC_ADDR  uint8_t(0x76)");
    Blockly.Arduino.addDeclaration('init_bmp680', "Seeed_BME680 bme680(BME_IIC_ADDR);");
    Blockly.Arduino.addFunction('func_bme680_measure', DEF_BME680_MEASURE);
    var baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup('setup_bme680_check', "while (!bme680.init()) {" + NEWLINE + "  Serial.println(\"En attente du capteur BME680...\");" + NEWLINE + "  delay(1000);" + NEWLINE + "}");
    switch (this.getFieldValue("DATA")) {
        case "0":
            Blockly.Arduino.addFunction('func_bme680_temp', DEF_BME680_GET_TEMPERATURE);
            return ['get_bme680_temperature()', Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            Blockly.Arduino.addFunction('func_bme680_pressure', DEF_BME680_GET_PRESSURE);
            return ['get_bme680_pressure()', Blockly.Arduino.ORDER_ATOMIC];
        case "2":
            Blockly.Arduino.addFunction('func_bme680_humidity', DEF_BME680_GET_HUMIDITY);
            return ['get_bme680_humidity()', Blockly.Arduino.ORDER_ATOMIC];
        case "3":
            Blockly.Arduino.addFunction('func_bme680_gas', DEF_BME680_GET_GAS);
            return ['get_bme680_gas()', Blockly.Arduino.ORDER_ATOMIC];
    }
};
// GROVE ONE WIRE DS18B20 _ READ TEMPERATURE
Blockly.Arduino.sensors_ds18b20_getTemperature = function () {
    Blockly.Arduino.addInclude('include_one_wire', INCLUDE_ONE_WIRE);
    Blockly.Arduino.addDeclaration('declare_ds18b20_setup', DEF_DS18B20_ERRORS);
    Blockly.Arduino.addDeclaration("setup_ds18b20", "OneWire ds18b20(" + this.getFieldValue("PIN") + ");");
    Blockly.Arduino.addFunction('func_ds18b20_measure', DEF_DS18B20_MEASURE);
    Blockly.Arduino.addFunction('func_ds18b20_get', DEF_DS18B20_GET_TEMPERATURE);
    return ["getTemperature_DS18()", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE WATER SENSOR _ READ STATE 
Blockly.Arduino.sensors_getGroveWaterAmount = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// READ RAIN GRLEX STATEMENT ON PIN D BLOCK
Blockly.Arduino.sensors_getRainGauge = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// READ ANEMOMETER STATEMENT ON PIN D BLOCK
Blockly.Arduino.sensors_getAnemometer = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE LIGHT SENSOR _ READ VALUE ON PIN A BLOCK
Blockly.Arduino.sensors_getGroveLight = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["analogRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// SI1145 SENSOR _ READ LIGHT BLOCK
Blockly.Arduino.sensors_getSi1145Light = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_adafruit_si1145', INCLUDE_ADAFRUIT_SI1145);
    Blockly.Arduino.addDeclaration('init_si1145', "Adafruit_SI1145 light = Adafruit_SI1145();");
    var baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup('setup_si1145_check', "if (!light.begin()) {\n\tSerial.println(\"En attente du capteur Si1145...\");\n\twhile (1);\n\t}\nSerial.println(\"Light sensor Si1145 ready!\");");
    switch (this.getFieldValue("LIGHT")) {
        case "0":
            return ['light.readUV()', Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            return ['light.readVisible()', Blockly.Arduino.ORDER_ATOMIC];
        case "2":
            return ['light.readIR()', Blockly.Arduino.ORDER_ATOMIC];
    }
};
// GROVE UV SENSOR _ READ UV INDEX
//http://wiki.seeedstudio.com/Grove-UV_Sensor/
Blockly.Arduino.sensors_getUVindex = function () {
    Blockly.Arduino.addFunction('func_get_uv_index', DEF_GET_UV_INDEX);
    return ["getUVindex(" + this.getFieldValue("PIN") + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE SOUND SENSOR _ READ VALUE BLOCK ON PIN A BLOCK
// http://wiki.seeedstudio.com/Grove-Sound_Sensor/
Blockly.Arduino.sensors_getGroveSound = function () {
    Blockly.Arduino.addFunction('func_getSound', DEF_SENSOR_GET_SOUND);
    return ["getSound(" + this.getFieldValue("PIN") + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE i2C COLOR SENSOR _ READ COLOR BLOCK
// http://wiki.seeedstudio.com/Grove-I2C_Color_Sensor/  
Blockly.Arduino.sensors_colorSensor_getData = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_grove_color_sensor', INCLUDE_ADAFRUIT_TCS34725);
    Blockly.Arduino.addDeclaration('init_color_sensor', "Adafruit_TCS34725 colorSensor = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_24MS); //max = 20480");
    Blockly.Arduino.addFunction('func_setup_color', DEF_COLOR_SENSOR_SETUP);
    Blockly.Arduino.addFunction('func_get_color_sensor', DEF_COLOR_SENSOR_GET_DATA);
    let baud = document.getElementById("baud");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup("setup_color_sensor", "colorSensor_setup();");
    return ["colorSensor_getData(" + this.getFieldValue("DATA") + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// SNAPSHOT AND SAVE IN MICROSD BLOCK
Blockly.Arduino.sensors_cameraTakePicture = function () {
    let baud = document.getElementById("baud");
    let pinDigi = Blockly.Arduino.valueToCode(this, "VALUE", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addInclude('include_software_serial_2', INCLUDE_SOFTWARE_SERIAL_2);
    Blockly.Arduino.addInclude('include_adafruit_vc0706', INCLUDE_ADAFRUIT_VC0706);
    Blockly.Arduino.addInclude('include_sd', INCLUDE_SD);
    Blockly.Arduino.addInclude('include_spi', INCLUDE_SPI);
    Blockly.Arduino.addDeclaration('init_software_serial_2', "SoftwareSerial cameraconnection = SoftwareSerial(2, 3);");
    Blockly.Arduino.addDeclaration('init_vc0706', "Adafruit_VC0706 cam = Adafruit_VC0706(&cameraconnection);");
    Blockly.Arduino.addSetup('pin_' + pinDigi, "pinMode(" + pinDigi + ", OUTPUT);");
    Blockly.Arduino.addSetup("setup_serial", "Serial.begin(" + baud.value + ");");
    Blockly.Arduino.addSetup("setup_serial_check", SETUP_SERIAL_CHECK);
    Blockly.Arduino.addSetup('setup_sd_check', "while(!SD.begin(" + pinDigi + ")) {\nSerial.println(\"La carte SD n'est pas presente.\");\n}");
    Blockly.Arduino.addSetup("setup_camera_check", "while(!cam.begin()) {\nSerial.println(\"La camera n'est pas presente.\");\n}");
    Blockly.Arduino.addSetup("setup_camera", "cam.setImageSize(VC0706_640x480);");
    Blockly.Arduino.addFunction("func_takePic", DEF_TAKE_PICTURE);
    return "takePicture()" + NEWLINE;
};
// GROVE ULTRASONIC SENSOR _ GET DISTANCE
Blockly.Arduino.sensors_getGroveUltrasonicRanger = function () {
    Blockly.Arduino.addInclude('include_ultrasonic', INCLUDE_ULTRASONIC);
    Blockly.Arduino.addDeclaration('init_ultrasonic', "Ultrasonic ultrasonic(" + this.getFieldValue("PIN") + ");");
    switch(this.getFieldValue("DATA")) {
        case "0":
            return ["ultrasonic.MeasureInCentimeters()", Blockly.Arduino.ORDER_ATOMIC]
        case "1":
            return ["ultrasonic.MeasureInCentimeters()*29", Blockly.Arduino.ORDER_ATOMIC]
    }
   
};
// GROVE GESTURE SENSOR _ GET TYPE
Blockly.Arduino.sensors_getGesture = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_gesture', INCLUDE_PAJ7620);
    Blockly.Arduino.addSetup('init_gesture', "paj7620Init();");
    Blockly.Arduino.addFunction('func_getGest', DEF_GESTURE_GET);
    return ['getGestureType()', Blockly.Arduino.ORDER_ATOMIC];
};
// GROVE LINE FINDER _ GET STATE
Blockly.Arduino.sensors_getGroveLineFinder = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE PIR MOTION _ GET STATE
Blockly.Arduino.sensors_getGroveMotion = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE PIEZO VIBRATION _ GET STATE
Blockly.Arduino.sensors_getPiezoVibration = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE TILT DETECTOR _ GET STATE
Blockly.Arduino.sensors_getGroveTilt = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["digitalRead(" + pin + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// INA219 CURRENT SENSOR
Blockly.Arduino.sensors_getIna219Data = function () {
    Blockly.Arduino.addInclude('include_wire', INCLUDE_WIRE);
    Blockly.Arduino.addInclude('include_adafruit_ina219', INCLUDE_ADAFRUIT_INA219);
    Blockly.Arduino.addDeclaration('init_ina219', "Adafruit_INA219 ina219;");
    switch (this.getFieldValue("DATA")) {
        case "0":
            return ["ina219.getBusVoltage_V()", Blockly.Arduino.ORDER_ATOMIC];
        case "1":
            return ["ina219.getShuntVoltage_mV()", Blockly.Arduino.ORDER_ATOMIC];
        case "2":
            return ["ina219.getBusVoltage_V() + (ina219.getShuntVoltage_mV()/1000)", Blockly.Arduino.ORDER_ATOMIC];
        case "3":
            return ["ina219.getCurrent_mA()", Blockly.Arduino.ORDER_ATOMIC];
        case "4":
            return ["ina219.getPower_mW()", Blockly.Arduino.ORDER_ATOMIC];
    }
};
// GROVE FORCE SENSOR (FSR402) 
Blockly.Arduino.sensors_getFsr402Force = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["analogRead(" + this.getFieldValue("PIN") + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// GROVE PUSLE SENSOR 
Blockly.Arduino.sensors_getPulse = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', INPUT);');
    return ["analogRead(" + this.getFieldValue("PIN") + ")", Blockly.Arduino.ORDER_ATOMIC]
};

/////////////////////////////////////////////// ACTUATORS CODE GENERATION BLOCKS ///////////////////////////////////////////////

// GROVE SERVOMOTOR _ CONTROL ANGLE BLOCK
Blockly.Arduino.actuators_setServoAngle = function () {
    Blockly.Arduino.addInclude('include_servo', INCLUDE_SERVO);
    Blockly.Arduino.addDeclaration('init_servo', "Servo myservo;");
    let value = Blockly.Arduino.valueToCode(this, "ANGLE", Blockly.Arduino.ORDER_ATOMIC);
    if (value < 0) value = 0;
    if (value > 180) value = 180;
    Blockly.Arduino.addSetup("setup_servo", "myservo.attach(" + this.getFieldValue("PIN") + ");");
    return "myservo.write(" + value + ");" + NEWLINE;
};
// GROVE VIBRATION MOTOR _ CONTROL STATE BLOCK
Blockly.Arduino.actuators_setVibrationMotorState = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "digitalWrite(" + pin + ", " + state + ");" + NEWLINE;
};
// GROVE RELAY _ CONTROL STATE BLOCK
Blockly.Arduino.actuators_setGroveRelayState = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "digitalWrite(" + pin + ", " + state + ");" + NEWLINE + "delay(100);" + NEWLINE;
};
// GROVE BUZZER _ CONTROL STATE BLOCK
Blockly.Arduino.actuators_controlGroveBuzzerState = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "digitalWrite(" + pin + ", " + state + ");" + NEWLINE;
};
// GROVE BUZZER _ PLAY NOTE BLOCK
Blockly.Arduino.actuators_playNoteGroveBuzzer = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup('pin_' + pin, "pinMode(" + pin + ",OUTPUT);");
    return "tone(" + pin + ", " + this.getFieldValue("Note") + ");" + NEWLINE;
};
// GROVE BUZZER _ PLAY MUSIC BLOCK
Blockly.Arduino.actuators_playMusicGroveBuzzer = function () {
    var pin = this.getFieldValue("PIN");
    switch (this.getFieldValue("MUSIC")) {
        case "0":
            Blockly.Arduino.addFunction('func_music_G', DEF_BUZZER_GAMME);
            return "BuzzerGamme(" + pin + ")" + NEWLINE;
        case "1":
            Blockly.Arduino.addFunction('func_music_SW', DEF_BUZZER_STARWARS);
            return "BuzzerStarWars(" + pin + ")" + NEWLINE;
        case "2":
            Blockly.Arduino.addFunction('func_music_R2D2', DEF_BUZZER_R2D2);
            return "BuzzerR2D2(" + pin + ")" + NEWLINE;
        default:
            throw Error("Unhandled option (lists_getSublist)");
    }
};
// GROVE BUZZER _ PLAY FREQUENCY (TONE) BLOCK
Blockly.Arduino.actuators_tone = function () {
    var pin = this.getFieldValue("PIN");
    var f = Blockly.Arduino.valueToCode(this, "FREQUENCY", Blockly.Arduino.ORDER_ATOMIC);
    Blockly.Arduino.addSetup("pin_" + pin, "pinMode(" + pin + ", OUTPUT);" + NEWLINE, !1);
    return "tone(" + pin + ", " + f + ");" + NEWLINE;
};
// GROVE BUZZER _ STOP FREQUENCY (NOTONE) BLOCK
Blockly.Arduino.actuators_noTone = function () {
    var pin = this.getFieldValue("PIN");
    Blockly.Arduino.addSetup("pin_" + pin, "pinMode(" + pin + ", OUTPUT);" + NEWLINE, !1);
    return "noTone(" + pin + ");" + NEWLINE;
};
// GROVE VIBRATION MOTOR _ CONTROL STATE BLOCK
Blockly.Arduino.actuators_setWaterAtomizerState = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "digitalWrite(" + pin + ", " + state + ");" + NEWLINE;
};
// GROVE ELECTROMAGNET _ CONTROL STATE BLOCK
Blockly.Arduino.actuators_setElectromagnetState = function () {
    var pin = this.getFieldValue("PIN");
    var state = Blockly.Arduino.valueToCode(this, "STATE", Blockly.Arduino.ORDER_ATOMIC) || 'LOW';
    Blockly.Arduino.addSetup('pin_' + pin, 'pinMode(' + pin + ', OUTPUT);');
    return "digitalWrite(" + pin + ", " + state + ");" + NEWLINE;
};
/////////////////////////////////////////////// ROBOTS CODE GENERATION BLOCKS ///////////////////////////////////////////////

// MBOT - GO FORWARD/REVERSE
Blockly.Arduino.robots_setmBotGo = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addFunction('func_mbot_go', DEF_MBOT_GO);
    Blockly.Arduino.addDeclaration('init_mbot_motorR', "MeDCMotor motor_R(9);");
    Blockly.Arduino.addDeclaration('init_mbot_motorL', "MeDCMotor motor_L(10);");
    var speed = Blockly.Arduino.valueToCode(this, "SPEED", Blockly.Arduino.ORDER_NONE) || 0;
    if (speed > 255) speed = 255;
    if (speed < 0) speed = 0;
    return "moveMBot(" + this.getFieldValue('DIR') + ", " + speed + ");" + NEWLINE;
};
// MBOT - CONTROL MOTOR SPEED
Blockly.Arduino.robots_controlmBotMotor = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    let speed = Blockly.Arduino.valueToCode(this, "SPEED", Blockly.Arduino.ORDER_NONE) || 0;
    if (speed > 255) speed = 255;
    if (speed < 0) speed = 0;
    let dir = this.getFieldValue("DIR");
    switch (this.getFieldValue("MOTOR")) {
        case "9":
            Blockly.Arduino.addDeclaration('init_mbot_motorR', "MeDCMotor motor_R(9);");
            return "motor_R.run((9)==M1?-(" + dir + "*speed):(" + dir + "*speed));" + NEWLINE;
        case "10":
            Blockly.Arduino.addDeclaration('init_mbot_motorL', "MeDCMotor motor_L(10);");
            return "motor_L.run((10)==M1?-(" + dir + "*speed):(" + dir + "*speed));" + NEWLINE;
    }
};
// MBOT - STOP MOTORS
Blockly.Arduino.robots_stopmBotMotors = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    if (this.getFieldValue('MOTOR') == "all") {
        Blockly.Arduino.addDeclaration('init_mbot_motorR', "MeDCMotor motor_R(9);");
        Blockly.Arduino.addDeclaration('init_mbot_motorL', "MeDCMotor motor_L(10);");
        Blockly.Arduino.addFunction('func_mbot_go', DEF_MBOT_GO);
        return "moveMBot(0, 0);" + NEWLINE;
    } else {
        switch (this.getFieldValue("MOTOR")) {
            case "9":
                Blockly.Arduino.addDeclaration('init_mbot_motorR', "MeDCMotor motor_R(9);");
                return "motor_R.run((9)==M1?-(0):(0));" + NEWLINE;
            case "10":
                Blockly.Arduino.addDeclaration('init_mbot_motorL', "MeDCMotor motor_L(10);");
                return "motor_L.run((10)==M1?-(0):(0));" + NEWLINE;
        }
    }
};
// MBOT - SET RGB LED
Blockly.Arduino.robots_setmBotRgbLed = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_mbot_rgb', "MeRGBLed rgbled(7, 7==7?2:4);");
    var r = Blockly.Arduino.valueToCode(this, "R", Blockly.Arduino.ORDER_NONE) || 0;
    var g = Blockly.Arduino.valueToCode(this, "G", Blockly.Arduino.ORDER_NONE) || 0;
    var b = Blockly.Arduino.valueToCode(this, "B", Blockly.Arduino.ORDER_NONE) || 0;
    if (r > 255) r = 255;
    if (r < 0) r = 0;
    if (g > 255) g = 255;
    if (g < 0) g = 0;
    if (b > 255) b = 255;
    if (b < 0) b = 0;
    return "rgbled.setColor(" + this.getFieldValue("LED") + ", " + r + ", " + g + ", " + b + ");" + NEWLINE + "rgbled.show();" + NEWLINE;
};
// MBOT - SET BUZZER FREQUENCY
Blockly.Arduino.robots_setmBotBuzzer = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_mbot_buzzer', "MeBuzzer buzzer;");
    let freq = Blockly.Arduino.valueToCode(this, "FREQ", Blockly.Arduino.ORDER_NONE) || "0";
    let time = Blockly.Arduino.valueToCode(this, "TIME", Blockly.Arduino.ORDER_NONE) || "0";
    return "buzzer.tone(" + freq + ", " + time + ");" + NEWLINE;
};
// MBOT - SET BUZZER MUSIC
Blockly.Arduino.robots_playmBotMusic = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_mbot_buzzer', "MeBuzzer buzzer;");
    switch (this.getFieldValue("MUSIC")) {
        case "0":
            Blockly.Arduino.addFunction('func_music_G', DEF_MBOT_BUZZER_GAMME);
            return "BuzzerGamme();" + NEWLINE;
        case "1":
            Blockly.Arduino.addFunction('func_music_SW', DEF_MBOT_BUZZER_STARWARS);
            return "BuzzerStarWars();" + NEWLINE;
        case "2":
            Blockly.Arduino.addFunction('func_music_R2D2', DEF_MBOT_BUZZER_R2D2);
            return "BuzzerR2D2();" + NEWLINE;
        default:
            throw Error("Unhandled option (lists_getSublist)");
    }
};
// MBOT - GET LIGHT
Blockly.Arduino.robots_getmBotSensorLight = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_light_sensor', "MeLightSensor lightsensor_6(6)");
    return ["lightsensor_6.read()", Blockly.Arduino.ORDER_ATOMIC]
};
// MBOT - GET BUTTON STATE
Blockly.Arduino.robots_getmBotButtonState = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addSetup('setup_button', "pinMode(A7,INPUT);");
    return ["(" + this.getFieldValue("STATE") + "^(analogRead(A7)>10?0:1))", Blockly.Arduino.ORDER_ATOMIC]
};
// MBOT - GET REMOTE CONTROL BUTTON
Blockly.Arduino.robots_getmBotRemoteControlButton = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('declare_remote_control', "MeIR ir;");
    Blockly.Arduino.addSetup('setup_remote_control', "ir.begin();");
    return ["ir.keyPressed(" + this.getFieldValue("BUTTON") + ")", Blockly.Arduino.ORDER_ATOMIC]
};
// MAKEBLOCK - GET ULTRASONIC RANGER
Blockly.Arduino.robots_makeBlock_getUltrasonicRanger = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_makeBlock_ultrasonic', "MeUltrasonicSensor ultrasonic(" + this.getFieldValue("PORT") + ");");
    return ["ultrasonic.distance" + this.getFieldValue("UNIT") + "()", Blockly.Arduino.ORDER_ATOMIC]
};
// MAKEBLOCK - GET LINE FINDER STATE
Blockly.Arduino.robots_makeBlock_getLineState = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_lmakeBlock_line', "MeLineFollower lineFinder(" + this.getFieldValue("PORT") + ");");
    return ["lineFinder.readSensor" + this.getFieldValue("SENSOR") + "()", Blockly.Arduino.ORDER_ATOMIC]
};
// MAKEBLOCK - READ COLOR
Blockly.Arduino.robots_makeBlock_getColor = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_makeBlock_color', "MeColorSensor colorSensor(" + this.getFieldValue("PORT") + ");");
    Blockly.Arduino.addSetup("setup_makeBlock_color", "colorSensor.SensorInit();");
    switch(this.getFieldValue("DATA")) {
        case "0":
            return ["colorSensor.Returnresult()", Blockly.Arduino.ORDER_ATOMIC]
        case "1":
            Blockly.Arduino.addFunction('func_get_color_sensor', DEF_MAKEBLOCK_COLOR_SENSOR_GET_COLOR);
            return ["colorSensor_getData(" + this.getFieldValue("DATA") + ")", Blockly.Arduino.ORDER_ATOMIC]
        case "2":
            Blockly.Arduino.addFunction('func_get_color_sensor', DEF_MAKEBLOCK_COLOR_SENSOR_GET_COLOR);
            return ["colorSensor_getData(" + this.getFieldValue("DATA") + ")", Blockly.Arduino.ORDER_ATOMIC]
        case "3":
            Blockly.Arduino.addFunction('func_get_color_sensor', DEF_MAKEBLOCK_COLOR_SENSOR_GET_COLOR);
            return ["colorSensor_getData(" + this.getFieldValue("DATA") + ")", Blockly.Arduino.ORDER_ATOMIC]
    }
};
// MAKEBLOCK - READ GAS INFORMATION
Blockly.Arduino.robots_makeBlock_MQ2_getGas = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_makeBlock_gas', "MeColorSensor gasSensor(" + this.getFieldValue("PORT") + ");");
    return ["gasSensor.read" + this.getFieldValue("TYPE") + "()", Blockly.Arduino.ORDER_ATOMIC]
};
// MAKEBLOCK - READ FLAME INFORMATION
Blockly.Arduino.robots_makeBlock_getFlame = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_makeBlock_flame', "MeFlameSensor flameSensor(" + this.getFieldValue("PORT") + ");");
    return ["flameSensor.read" + this.getFieldValue("TYPE") + "()", Blockly.Arduino.ORDER_ATOMIC]
};
// MAKEBLOCK - GET WATERPROOF TEMPERATURE
Blockly.Arduino.robots_makeBlock_getWaterproofTemperature = function () {
    Blockly.Arduino.addInclude('include_me_core', INCLUDE_ME_CORE);
    Blockly.Arduino.addDeclaration('init_makeBlock_ds18b20', "MeTemperature ds18b20Sensor(" + this.getFieldValue("PORT") + ");");
    return ["ds18b20Sensor.temperature()", Blockly.Arduino.ORDER_ATOMIC]
};

/////////////////////////////////////////////// COLOUR CODE GENERATION BLOCKS ///////////////////////////////////////////////

Blockly.Arduino.colour_picker = function (a) {
    let colourCode = a.getFieldValue("COLOUR"),
        R = hexToR(colourCode),
        G = hexToG(colourCode),
        B = hexToB(colourCode);
    return [R + ', ' + G + ', ' + B, Blockly.Arduino.ORDER_ATOMIC]
};

/*
Blockly.Arduino.colour_random = Blockly.Arduino.noGeneratorCodeInline;
Blockly.Arduino.colour_rgb = Blockly.Arduino.noGeneratorCodeInline;
Blockly.Arduino.colour_blend = Blockly.Arduino.noGeneratorCodeInline;

/*  Not yet used

Blockly.Arduino.spi_setup = function(a) {
    var b = a.getFieldValue("SPI_ID"),
        c = a.getFieldValue("SPI_SHIFT_ORDER"),
        d = a.getFieldValue("SPI_CLOCK_DIVIDE");
    a = a.getFieldValue("SPI_MODE");
    Blockly.Arduino.addInclude("spi", INCLUDE_SPI);
    Blockly.Arduino.addSetup("spi_order", b + ".setBitOrder(" + c + ");", !0);
    Blockly.Arduino.addSetup("spi_mode", b + ".setDataMode(" + a + ");", !0);
    Blockly.Arduino.addSetup("spi_div", b + ".setClockDivider(" + d + ");", !0);
    Blockly.Arduino.addSetup("spi_begin", b + ".begin();", !0);
    return ""
};
Blockly.Arduino.spi_transfer = function(a) {
    var b = a.getFieldValue("SPI_ID"),
        c = a.getFieldValue("SPI_SS"),
        d = Blockly.Arduino.valueToCode(a, "SPI_DATA", Blockly.Arduino.ORDER_ATOMIC) || "0";
    Blockly.Arduino.addInclude("spi", INCLUDE_SPI);
    Blockly.Arduino.addSetup("spi_begin", b + ".begin();", !1);
    for (var e = Blockly.Arduino.Boards.selected.spiPins[b], f = 0; f < e.length; f++) Blockly.Arduino.reservePin(a, e[f][1], Blockly.Arduino.PinTypes.SPI, "SPI " + e[f][0]);
    "none" !== c && (Blockly.Arduino.reservePin(a, c, Blockly.Arduino.PinTypes.OUTPUT,
        "SPI Slave pin"), Blockly.Arduino.addSetup("io_" + c, "pinMode(" + c + ", OUTPUT);", !1));
    a = [];
    "none" !== c && a.push("digitalWrite(" + c + ", HIGH);");
    a.push(b + ".transfer(" + d + ");");
    "none" !== c && a.push("digitalWrite(" + c + ", LOW);");
    return a.join("\n") + "\n"
};
Blockly.Arduino.spi_transfer_return = function(a) {
    var b = a.getFieldValue("SPI_ID"),
        c = a.getFieldValue("SPI_SS"),
        d = Blockly.Arduino.valueToCode(a, "SPI_DATA", Blockly.Arduino.ORDER_ATOMIC) || "0";
    Blockly.Arduino.spi_transfer(a);
    return ["none" === c ? b + ".transfer(" + d + ")" : Blockly.Arduino.addFunction("spiReturnSlave" + c, ["int " + Blockly.Arduino.DEF_FUNC_NAME + "() {", "  int spiReturn = 0;", "  digitalWrite(" + c + ", HIGH);", "  spiReturn = " + b + ".transfer(" + d + ");", "  digitalWrite(" + c + ", LOW);", "  return spiReturn;\n}"].join("\n")) +
        "()", Blockly.Arduino.ORDER_UNARY_POSTFIX
    ]
};

Blockly.Arduino.stepper_config = function(a) {
    var b = Blockly.Arduino.PinTypes.STEPPER,
        c = a.getFieldValue("STEPPER_NAME"),
        d = a.getFieldValue("STEPPER_NUMBER_OF_PINS"),
        e = Blockly.Arduino.valueToCode(a, "STEPPER_STEPS", Blockly.Arduino.ORDER_ATOMIC) || "360",
        f = Blockly.Arduino.valueToCode(a, "STEPPER_SPEED", Blockly.Arduino.ORDER_ATOMIC) || "90",
        g = [a.getFieldValue("STEPPER_PIN1"), a.getFieldValue("STEPPER_PIN2")];
    "FOUR" === d && (g.push(a.getFieldValue("STEPPER_PIN3")), g.push(a.getFieldValue("STEPPER_PIN4")));
    for (var d =
            "int " + c + "[" + g.length + "] = {", e = "Stepper stepper_" + c + "(" + e + ", ", h = 0; h < g.length; h++) Blockly.Arduino.reservePin(a, g[h], b, "Stepper"), d += g[h] + ", ", e += g[h] + ", ";
    d = d.slice(0, -2) + "};";
    e = e.slice(0, -2) + ");";
    Blockly.Arduino.addVariable(c, d, !0);
    c = "stepper_" + c;
    Blockly.Arduino.addInclude("stepper", "#include <Stepper.h>");
    Blockly.Arduino.addDeclaration(c, e);
    Blockly.Arduino.addSetup(c, c + ".setSpeed(" + f + ");", !0);
    return ""
};
Blockly.Arduino.stepper_step = function(a) {
    var b = "stepper_" + a.getFieldValue("STEPPER_NAME");
    a = Blockly.Arduino.valueToCode(a, "STEPPER_STEPS", Blockly.Arduino.ORDER_ATOMIC) || "0";
    return b + ".step(" + a + ");\n"
};
*/